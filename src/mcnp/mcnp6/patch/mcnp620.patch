diff -rN '--unified=0' Source/import/laqmod31.F90 Source_dagmc/import/laqmod31.F90
--- Source/import/laqmod31.F90
+++ Source_dagmc/import/laqmod31.F90
@@ -41114 +41113,0 @@
-      use mcnp_random, only : rang
@@ -41155 +41153,0 @@
-      use mcnp_random, only : rang
@@ -42270 +42267,0 @@
-      use mcnp_random, only : rang
@@ -42706 +42702,0 @@
-      use mcnp_random, only : rang
@@ -42939 +42934,0 @@
-      use mcnp_random, only : rang
@@ -42972 +42966,0 @@
-      use mcnp_random, only : rang
@@ -42994 +42987,0 @@
-      use mcnp_random, only : rang
@@ -43153 +43145,0 @@
-      use mcnp_random, only : rang
@@ -43209 +43200,0 @@
-      use mcnp_random, only : rang
@@ -43237 +43227,0 @@
-      use mcnp_random, only : rang
@@ -43257 +43246,0 @@
-      use mcnp_random, only : rang
@@ -43310 +43298,0 @@
-      use mcnp_random, only : rang
@@ -43343 +43330,0 @@
-      use mcnp_random, only : rang
@@ -43536 +43522,0 @@
-      use mcnp_random, only : rang
@@ -43639 +43624,0 @@
-      use mcnp_random, only : rang
@@ -43842 +43826,0 @@
-      use mcnp_random, only : rang
@@ -43928 +43911,0 @@
-      use mcnp_random, only : rang
@@ -43987 +43969,0 @@
-      use mcnp_random, only : rang
@@ -45528 +45509,0 @@
-      use mcnp_random, only : rang
@@ -45680 +45660,0 @@
-      use mcnp_random, only : rang
@@ -45855 +45834,0 @@
-      use mcnp_random, only : rang
@@ -45929 +45907,0 @@
-      use mcnp_random, only : rang
@@ -45963 +45940,0 @@
-      use mcnp_random, only : rang
diff -rN '--unified=0' Source/src/angl.F90 Source_dagmc/src/angl.F90
--- Source/src/angl.F90
+++ Source_dagmc/src/angl.F90
@@ -14,0 +15 @@
+  use dagmc_mod,   only : isdgmc
@@ -30,0 +32,6 @@
+  ! DAGMC: In CAD mode, circumvent entire function and call DAGMC version instead
+  if (isdgmc == 1) then
+    call dagmcangl(pbl%i%jsu, pbl%r%x, pbl%r%y, pbl%r%z, sur_norm)
+    cos_theta = max(-one, min(one, sur_norm(1)*pbl%r%u + sur_norm(2)*pbl%r%v + sur_norm(3)*pbl%r%w))
+    return
+  endif
diff -rN '--unified=0' Source/src/bankit.F90 Source_dagmc/src/bankit.F90
--- Source/src/bankit.F90
+++ Source_dagmc/src/bankit.F90
@@ -73,0 +74 @@
+    use dagmc_mod, only : isdgmc
@@ -130,0 +132,5 @@
+    ! DAGMC:
+    if ( isdgmc == 1 ) then
+      call dagmc_bank_push( nbnk )
+    endif
+
@@ -300,0 +307 @@
+    use dagmc_mod, only : isdgmc
@@ -311,0 +319,5 @@
+  ! DAGMC:
+    if ( isdgmc == 1 ) then
+      call dagmc_bank_usetop()
+    endif
+
@@ -413,0 +426,4 @@
+      ! DAGMC:
+      if ( isdgmc == 1 ) then
+        call dagmc_bank_pop( nbnk )
+      endif
diff -rN '--unified=0' Source/src/celsrf.F90 Source_dagmc/src/celsrf.F90
--- Source/src/celsrf.F90
+++ Source_dagmc/src/celsrf.F90
@@ -24,0 +25 @@
+  use dagmc_mod, only : isdgmc
@@ -452 +453,6 @@
-    write(iuo,460) js,j1,hq,hl,ht,surface_card(k)%symbol,(tpp(i),i=1,n)
+    ! DAGMC: surface_card(k)%symbol returns null characters in DAGMC mode
+    if (isdgmc == 1) then
+      write(iuo,460) js,j1,hq,hl,ht,'',(tpp(i),i=1,n)
+    else
+      write(iuo,460) js,j1,hq,hl,ht,surface_card(k)%symbol,(tpp(i),i=1,n)
+    endif
@@ -508,0 +515,3 @@
+    ! DAGMC: Skip this loop if in CAD mode
+    if (isdgmc == 1) exit
+
diff -rN '--unified=0' Source/src/charged_particle_history.F90 Source_dagmc/src/charged_particle_history.F90
--- Source/src/charged_particle_history.F90
+++ Source_dagmc/src/charged_particle_history.F90
@@ -416,0 +417,5 @@
+
+        ! DAGMC: if minimum distance to next event is exactly zero, skip the
+        ! charged particle physics and go directly to the surface crossing
+        if( d_step_inter_decay_surf == zero ) goto 101
+
@@ -745,0 +751,2 @@
+
+101     continue  ! DAGMC jump target
diff -rN '--unified=0' Source/src/chkcel.F90 Source_dagmc/src/chkcel.F90
--- Source/src/chkcel.F90
+++ Source_dagmc/src/chkcel.F90
@@ -34,0 +35 @@
+  use dagmc_mod,    only: isdgmc
@@ -66,0 +68,5 @@
+  ! DAGMC: In CAD mode, circumvent this function and call DAGMC version instead
+  if ( isdgmc == 1 .and. (m == 0 .or. m == 2) ) then
+    call dagmcchkcel(pbl%r%u, pbl%r%v, pbl%r%w, pbl%r%x, pbl%r%y, pbl%r%z, icell, jresult)
+    return
+  endif
diff -rN '--unified=0' Source/src/dagmc_mod.F90 Source_dagmc/src/dagmc_mod.F90
--- Source/src/dagmc_mod.F90
+++ Source_dagmc/src/dagmc_mod.F90
@@ -0,0 +1,226 @@
+module dagmc_mod
+
+  use mcnp_params
+
+  integer, parameter, public :: &  ! named constant for file distribution mode
+    & DGFM_SEQ   = 0, &
+    & DGFM_READ  = 1, &
+    & DGFM_BCAST = 2
+
+  integer, save :: isdgmc
+
+  integer, save :: dagmc_geom_file_mode = DGFM_SEQ  ! default to a distributed read
+
+  integer, save :: dagmc_srcmode = 0
+  integer, save :: dagmc_usecad  = 0
+  integer, save :: dagmc_distlimit = 0
+
+  integer :: mpb = 5  ! this is the value of pbl_capacity in pblcom.F90
+
+  real(dknd), save :: dagmc_facet_tol
+  real(dknd), save :: dagmc_overlap_thickness
+  real(dknd), save :: dagmc_version
+
+  integer, save :: dagmc_subversion
+
+  public :: &
+    &   lcadrd, &        ! read log file information
+    &   dagmc_msgbcast   ! broadcast dagmc settings from master to slave tasks
+
+contains
+
+  subroutine lcadrd
+    ! Description:
+    ! Reads in the CAD log file and "inserts" it at the header
+    ! of the input file.
+
+    ! >>>>> Modules used
+    use mcnp_iofiles, only : inp, lcad
+
+    ! >>>>> Implict declaration of real variables as doubles
+    implicit real(dknd) (a-h,o-z)
+
+    ! >>>>> Other variables
+    character(len=80)  :: hk          ! Character for line of file being read
+    integer, parameter :: ie = 70     ! I/O index of a scratch file
+    integer            :: it, iu = 0  ! Indices for nxtsym function
+    integer            :: ios = 0     ! IOSTAT for file reading
+
+    ! >>>>> Initialize the scratch file and get to beginning of input file
+    open(ie, status='scratch')
+    rewind iui
+
+    ! >>>>> Check if first line is message block, otherwise assume a title card
+    read(iui, '(a80)', end=1000) hk
+    call nxtsym(hk, ' ', 1, it, iu, 1)
+
+    if ( hk(it:iu) == 'message:' ) then
+      ! Message block exists, read until blank line found
+      do
+        read(iui, '(a80)', end=1000) hk  ! Read in string: exception for eof
+        if ( hk == ' ' ) exit            ! Terminate loop once blank line found
+      enddo
+      ! Read in title card, for message block case
+      read(iui, '(a80)', end=1000) hk
+    endif
+
+    ! Write title card to scratch file
+    write(ie, '(a80)') hk
+
+    ! >>>>> Read in cell/surface cards from log
+    rewind iulc
+    do
+      read(iulc, '(a80)', iostat=ios) hk
+
+      ! Check for end of file or errors
+      if ( ios == 0 ) then
+        write(ie, '(a80)') hk  ! Write the line normally
+      elseif ( ios < 0 ) then
+        exit                   ! Break loop at EOF
+      else
+        goto 2000              ! Exception for severe I/O error
+      endif
+    enddo
+
+    ! >>>> Read in rest of input file
+    ios = 0
+    do
+      read(iui, '(a80)', iostat=ios) hk
+
+      ! Check for end of file or errors
+      if ( ios == 0 ) then
+        write(ie, '(a80)') hk  ! Write the line to scratch file
+      elseif ( ios < 0 ) then
+        exit                   ! Break loop at EOF
+      else
+        goto 3000              ! Exception for severe I/O error
+      endif
+    enddo
+
+    ! >>>>> Echo back to new scratch input file
+    close(iui)
+    rewind ie
+    open(iui, status='scratch')
+    ios = 0
+    do
+      read(ie, '(a80)', iostat=ios) hk
+
+      ! Check for end of file or errors
+      if ( ios == 0 ) then
+        write(iui, '(a80)') hk  ! Write the line in the scratch input file
+      elseif ( ios < 0 ) then
+        exit                    ! Break loop at EOF
+      else
+        goto 4000               ! Exception for severe I/O error
+      endif
+    enddo
+
+    ! >>>>> Finish up
+    rewind iui
+    ! pass1 expects iui to be advanced beyond the title card,
+    ! so read past the first line now
+    read(iui, '(a)')
+
+    close(ie)
+    return
+
+    ! >>>>> Exceptions
+    ! End of File at header of input file
+1000 call expire(0, 'lcadrd', 'unexpected eof in file '//inp%runtime_name)
+    return
+    ! Severe I/O error during reading of CAD log
+2000 call expire(0, 'lcadrd', 'error during read of file '//lcad%runtime_name)
+    return
+    ! Severe I/O error during reading of CAD log
+3000 call expire(0, 'lcadrd', 'error during read of file '//inp%runtime_name)
+    return
+    ! Severe I/O error during echo of scratch file to new input file
+4000 call expire(0, 'lcadrd', 'error stitching input and CAD log')
+    return
+
+  end subroutine lcadrd
+
+  subroutine dagmc_msgbcast
+
+    use messages,     only : msg_bcast
+    use mcnp_iofiles, only : gcad, ftol
+    use mcnp_debug
+
+    call msg_bcast(mynum, isdgmc)
+    call msg_bcast(mynum, dagmc_geom_file_mode)
+    call msg_bcast(mynum, gcad%runtime_name)
+    call msg_bcast(mynum, ftol%runtime_name)
+    call msg_bcast(mynum, dagmc_srcmode)
+    call msg_bcast(mynum, dagmc_usecad)
+    call msg_bcast(mynum, dagmc_distlimit)
+    call msg_bcast(mynum, dagmc_overlap_thickness)
+    call msg_bcast(mynum, dagmc_facet_tol)
+    call msg_bcast(mynum, dagmc_version)
+
+    if ( isdgmc == 1 ) then
+      call dagmcinit(gcad%runtime_name//char(0), len_trim(gcad%runtime_name), &
+        &            ftol%runtime_name//char(0), len_trim(ftol%runtime_name), &
+        &            dagmc_geom_file_mode, dagmc_version, dagmc_subversion, mpb)
+      if ( dagmc_version /= master_dagmc_version ) then
+        ! errprt and fail!
+      end if
+      call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, &
+        &                     dagmc_overlap_thickness, dagmc_srcmode)
+    end if
+
+  end subroutine dagmc_msgbcast
+
+  subroutine init_dagmc
+
+    use mcnp_iofiles, only : jtty, gcad, lcad, fcad, ftol, file_exists
+    use mcnp_env,     only : ver
+
+    ! Check to see if the CAD file exists, if not, abort
+    inquire(file=gcad%runtime_name, exist=file_exists)
+    if (.not.file_exists) then
+      call expire(0,'main','CAD geometry file '//gcad%runtime_name//' does not exist.')
+    endif
+
+    ! Initialize DAGMC, read geometry and initialize OBBTree
+    call dagmcinit(gcad%runtime_name//char(0), len_trim(gcad%runtime_name), &
+      &            ftol%runtime_name//char(0), len_trim(ftol%runtime_name), &
+      &            dagmc_geom_file_mode,dagmc_version, dagmc_subversion, mpb)
+
+    call dagmc_init_settings(dagmc_distlimit, dagmc_usecad, &
+      &                      dagmc_overlap_thickness, dagmc_facet_tol, &
+      &                      dagmc_srcmode)
+
+    ! Print version number message to terminal
+    call dagmc_version_heading(jtty)
+
+    ! Parse metadata and write input cards
+    call dagmcwritemcnp(gcad%runtime_name//char(0), lcad%runtime_name//char(0), &
+      &                 len_trim(lcad%runtime_name), ver(1:1)//char(0))
+
+    ! Write geometry file with OBB tree if requested
+    if ( len_trim(fcad%runtime_name) .gt. 0 ) then
+      call dagmcwritefacets(fcad%runtime_name//char(0), len_trim(fcad%runtime_name))
+    endif
+
+    ! Check to ensure that the log file is written
+    inquire(file=lcad%runtime_name, exist=file_exists)
+    if ( .not.file_exists ) then
+      call expire(0,'main','CAD list file '//lcad%runtime_name//' not written by DAGMC.')
+    endif
+
+    ! Open the cad log file on the MCNP side
+    open(unit=iulc, file=lcad%runtime_name, status='old')
+
+  end subroutine init_dagmc
+
+  ! write DagMC version number message to given file
+  subroutine dagmc_version_heading(o)
+
+    integer :: o
+
+    write(o,150) dagmc_version, dagmc_subversion
+150 format(1x,'This problem is using DAGMC version ',f8.3,' w/ DagMC r', i4)
+
+  end subroutine dagmc_version_heading
+
+end module dagmc_mod
diff -rN '--unified=0' Source/src/dbmin.F90 Source_dagmc/src/dbmin.F90
--- Source/src/dbmin.F90
+++ Source_dagmc/src/dbmin.F90
@@ -19,0 +20 @@
+  use dagmc_mod,    only : isdgmc
@@ -32,0 +34,10 @@
+
+  ! DAGMC: Explicitly declare variable for return value for inter-language call
+  real(dknd) :: dbmin_retval = zero
+
+  ! DAGMC: In CAD mode, call MOAB version instead
+  if ( isdgmc == 1 ) then
+    call dagmcdbmin(pbl%i%icl, pbl%r%x, pbl%r%y, pbl%r%z, huge_float, dbmin_retval)
+    dbmin = dbmin_retval
+    return
+  endif
diff -rN '--unified=0' Source/src/echkcl.F90 Source_dagmc/src/echkcl.F90
--- Source/src/echkcl.F90
+++ Source_dagmc/src/echkcl.F90
@@ -15,0 +16 @@
+  use dagmc_mod, only : isdgmc
@@ -32 +33,7 @@
-    call  chkcel(pbl%i%icl,2,j)
+    ! DAGMC
+    if( isdgmc == 1 ) then
+      call dagmcchkcel_by_angle( pbl%r%u, pbl%r%v, pbl%r%w, pbl%r%x, pbl%r%y, pbl%r%z, pbl%i%jsu, pbl%i%icl, j )
+      call dagmc_surf_reflection( pbl%r%u, pbl%r%v, pbl%r%w, 1 )
+    else
+      call chkcel(pbl%i%icl,2,j)
+    endif
diff -rN '--unified=0' Source/src/electr.F90 Source_dagmc/src/electr.F90
--- Source/src/electr.F90
+++ Source_dagmc/src/electr.F90
@@ -38,0 +39 @@
+  use dagmc_mod, only : isdgmc
@@ -170,0 +172,5 @@
+        ! DAGMC: In DAGMC mode, use the known physics distance to limit geometry search
+        if ( isdgmc == 1 ) then
+          d = min(pbl%r%dtc, pbl%r%dcs)
+          call dagmc_setdis(d)
+        endif
diff -rN '--unified=0' Source/src/fmesh_mod.F90 Source_dagmc/src/fmesh_mod.F90
--- Source/src/fmesh_mod.F90
+++ Source_dagmc/src/fmesh_mod.F90
@@ -40,0 +41,3 @@
+  public ::  dagmc_make_fortran_pointer  ! DAGMC
+  public ::  dagmc_setup_mesh_tally      ! DAGMC
+
@@ -43,0 +47,4 @@
+  logical, public :: enable_dag_tallies           = .false. ! DAGMC: Indicate any dagmc tally
+  logical, public :: enable_dag_collision_tallies = .false. ! DAGMC: Indicate a collision tally
+  logical, public :: enable_dag_track_tallies     = .false. ! DAGMC: Indicate a track tally
+
@@ -75 +82 @@
-  integer, parameter, public :: nfmesh_keyword_results = 15
+  integer, parameter, public :: nfmesh_keyword_results = 16
@@ -80 +87,2 @@
-  &     'yes       ','no        ','flux      ','source    ','none      ' /)
+  &     'yes       ','no        ','flux      ','source    ','none      ',   &
+  &     'dag       ' /)
@@ -199,0 +208,26 @@
+  ! DAGMC: These helper functions must be called with non-dereferenced Fortran pointers.
+  ! This interface specification ensures that the calls to these functions
+  ! (which are implemented in C) are made with the correct types
+  interface
+    subroutine dagmc_fmesh_get_tally_data( fm_id, fref ) bind(c)
+      implicit none
+      integer :: fm_id
+      ! The dknd parameter is unavailable in this scope for some reason,
+      ! so I have copied the definition of dknd from mcnp_params
+      real(selected_real_kind(15,307)) , dimension(:), pointer :: fref
+    end subroutine dagmc_fmesh_get_tally_data
+
+    subroutine dagmc_fmesh_get_error_data( fm_id, fref ) bind(c)
+      implicit none
+      integer :: fm_id
+      real(selected_real_kind(15,307)) , dimension(:), pointer :: fref
+    end subroutine dagmc_fmesh_get_error_data
+
+    subroutine dagmc_fmesh_get_scratch_data( fm_id, fref ) bind(c)
+      implicit none
+      integer :: fm_id
+      real(selected_real_kind(15,307)), dimension(:), pointer:: fref
+    end subroutine dagmc_fmesh_get_scratch_data
+
+  end interface
+
@@ -203,0 +238,60 @@
+  ! DAGMC: Helper function - create a valid Fortran pointer from a C array and a length
+  subroutine dagmc_make_fortran_pointer( fref, carray, size ) bind(c)
+    implicit none
+
+    integer :: size ! The size (in doubles) of the array in C
+    real(dknd), dimension(size), target :: carray ! The C pointer
+    real(dknd), dimension(:), pointer :: fref     ! The returned Fortran pointer
+
+    fref => carray
+
+  end subroutine dagmc_make_fortran_pointer
+
+  subroutine dagmc_setup_mesh_tally( idx )
+    implicit none
+    integer :: idx
+    integer :: dagmc_iscol
+    integer :: fmesh_idx
+
+    print *, shape(fm(idx)%fmarry)
+
+    ! Determine if DAGMC tally uses a multiplier
+    ! Default value of -1 indicates no multipliers are present
+    fmesh_idx = -1
+
+    ! Check for energy-dependent multipliers
+    if(fm(idx)%ifm_card/=0 .or. fm(idx)%icx == 1 .or. fm(idx)%intrpol /= 0) then
+      fmesh_idx = idx
+    elseif (fm(idx)%fmult > 0. .and. fm(idx)%fmult /= 1.) then
+      ! Constant multiplier only, not energy-dependent
+      fmesh_idx = idx
+    endif
+
+    ! Setup dagmc mesh; parameters will be read in from FC card
+    if( fm(idx)%n_comment_lines > 0 ) then
+       call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, fmesh_idx, &
+                                    fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                    fm(idx)%comment, fm(idx)%n_comment_lines, dagmc_iscol )
+    else
+      ! No FC card; avoid passing uninitialized pointer to C
+      ! The following call will halt mcnp with an error because of the missing card.
+      ! We could also signal an error and halt here instead.
+      call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, fmesh_idx, &
+                                   fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                   0, 0, dagmc_iscol )
+    endif
+
+    if( dagmc_iscol == 1 ) then
+      enable_dag_collision_tallies = .true.
+    else
+      enable_dag_track_tallies = .true.
+    endif
+
+    if ( fm(idx)%icrd == 3 .and. enable_dag_tallies .eqv. .false.) then
+      enable_dag_tallies = .true.
+    endif
+
+  end subroutine dagmc_setup_mesh_tally
+
+  !-----------------------------------------------------------------------------------------
+
@@ -217,0 +312,3 @@
+    ! DAGMC
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
+
@@ -269,0 +367,8 @@
+      ! DAGMC:
+      if ( fm(i)%icrd == 3 ) then
+        ! Get pointer to mesh's working data and fill runtpe with those contents
+        call dagmc_fmesh_get_tally_data( fm(i)%id, dagmc_runtpe_data )
+        write(iu) dagmc_runtpe_data
+        call dagmc_fmesh_get_error_data( fm(i)%id, dagmc_runtpe_data )
+        write(iu) dagmc_runtpe_data
+      endif
@@ -298,0 +404,3 @@
+    ! DAGMC
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
+
@@ -473,0 +582,11 @@
+
+      ! DAGMC:
+      if ( fm(i)%icrd == 3 ) then
+        if( .not. is_assoc ) call dagmc_setup_mesh_tally( i )
+        ! Get pointer to mesh's working memory and fill it with runtpe data
+        call dagmc_fmesh_get_tally_data( fm(i)%id, dagmc_runtpe_data )
+        read(iu) dagmc_runtpe_data
+        call dagmc_fmesh_get_error_data( fm(i)%id, dagmc_runtpe_data )
+        read(iu) dagmc_runtpe_data
+      endif
+
@@ -1110 +1229 @@
-    integer   :: i, ix, iy, iz, it, ie, is
+    integer   :: i, ix, iy, iz, it, ie, is, j
@@ -1217,0 +1337,16 @@
+      ! DAGMC: broadcast comment contents if this is a dagmc mesh
+      if ( fm(i)%icrd == 3 ) then
+        call msg_bcast(mynum, fm(i)%n_comment_lines)
+
+        if ( mynum > 0 ) then
+          allocate( fm(i)%comment( fm(i)%n_comment_lines ), stat=is )
+          if ( is /= 0 ) then
+            call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
+          endif
+        endif
+
+        do j = 1, fm(i)%n_comment_lines
+          call msg_bcast(mynum, fm(i)%comment(j))
+        enddo
+      endif
+
@@ -1265,0 +1401,8 @@
+
+      ! DAGMC:
+      do i = 1, nmesh
+        if( fm(i)%icrd == 3 ) then
+          call dagmc_setup_mesh_tally(i)
+        endif
+      enddo
+
@@ -1285,0 +1429,3 @@
+    ! DAGMC
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
@@ -1310 +1456,2 @@
-      isize = ix*iy*iz*it*ie
+      if( fm(i)%icrd /= 3 ) then
+        isize = ix*iy*iz*it*ie
@@ -1312,7 +1459,15 @@
-      ! use matching tag=555 in fmesh_msgtsk
-      call msg_recv( islave,555, fmtal(i)%tally(:,1,1,1,1,1), isize )
-      fm(i)%fmarry(:,:,:,:,:,1) = fm(i)%fmarry(:,:,:,:,:,1) + fmtal(i)%tally(:,:,:,:,:,1)
-
-      ! use matching tag=556 in fmesh_msgtsk
-      call msg_recv( islave,556, fmtal(i)%tally(:,1,1,1,1,2), isize )
-      fm(i)%fmerr( :,:,:,:,:,1) = fm(i)%fmerr( :,:,:,:,:,1) + fmtal(i)%tally(:,:,:,:,:,2)
+        ! use matching tag=555 in fmesh_msgtsk
+        call msg_recv( islave,555, fmtal(i)%tally(:,1,1,1,1,1), isize )
+        fm(i)%fmarry(:,:,:,:,:,1) = fm(i)%fmarry(:,:,:,:,:,1) + fmtal(i)%tally(:,:,:,:,:,1)
+
+        ! use matching tag=556 in fmesh_msgtsk
+        call msg_recv( islave,556, fmtal(i)%tally(:,1,1,1,1,2), isize )
+        fm(i)%fmerr( :,:,:,:,:,1) = fm(i)%fmerr( :,:,:,:,:,1) + fmtal(i)%tally(:,:,:,:,:,2)
+      else
+        ! DAGMC
+        call dagmc_fmesh_get_scratch_data(fm(i)%id, dagmc_mpi_data)
+        call msg_recv(islave, 557, dagmc_mpi_data, size(dagmc_mpi_data))
+        call dagmc_fmesh_add_scratch_to_tally(fm(i)%id)
+        call msg_recv(islave, 558, dagmc_mpi_data, size(dagmc_mpi_data))
+        call dagmc_fmesh_add_scratch_to_error(fm(i)%id)
+      endif
@@ -1336,0 +1492,3 @@
+    ! DAGMC
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
@@ -1352 +1510,2 @@
-      isize = ix*iy*iz*it*ie
+      if( fm(i)%icrd /= 3 ) then
+        isize = ix*iy*iz*it*ie
@@ -1354,7 +1513,14 @@
-      ! use matching tag=555 & tag=556 in fmesh_msgcon
-      call msg_send( 0,555, fm(i)%fmarry(:,1,1,1,1,1), isize )
-      call msg_send( 0,556, fm(i)%fmerr( :,1,1,1,1,1), isize )
-
-      ! zero arrays
-      fm(i)%fmarry(:,:,:,:,:,1) = zero
-      fm(i)%fmerr( :,:,:,:,:,1) = zero
+        ! use matching tag=555 & tag=556 in fmesh_msgcon
+        call msg_send( 0,555, fm(i)%fmarry(:,1,1,1,1,1), isize )
+        call msg_send( 0,556, fm(i)%fmerr( :,1,1,1,1,1), isize )
+
+        ! zero arrays
+        fm(i)%fmarry(:,:,:,:,:,1) = zero
+        fm(i)%fmerr( :,:,:,:,:,1) = zero
+      else
+        ! DAGMC
+        call dagmc_fmesh_get_tally_data(fm(i)%id, dagmc_mpi_data)
+        call msg_send(0, 557, dagmc_mpi_data, size(dagmc_mpi_data))
+        call dagmc_fmesh_get_error_data(fm(i)%id, dagmc_mpi_data)
+        call msg_send(0, 558, dagmc_mpi_data, size(dagmc_mpi_data))
+      endif
@@ -1380,0 +1547,5 @@
+    ! DAGMC: perform end of history tasks for all dagmc mesh tallies
+    if ( enable_dag_tallies ) then
+      call dagmc_fmesh_end_history()
+    endif
+
@@ -1457,0 +1629,27 @@
+  subroutine dagmc_get_multiplier( i, erg, multiplier )
+
+    use mcnp_params, only : dknd
+    use mcnp_global, only : rho
+    use pblcom,      only : pbl
+
+    integer   , intent(in) :: i
+    real(dknd), intent(in) :: erg
+    real(dknd), intent(out) :: multiplier
+    real(dknd) :: t
+
+    t = 1._dknd
+    if( fm(i)%ifm_card/=0 ) then
+      call wtmult_fmesh(t,i)
+    endif
+    t = t*fm(i)%fmult
+    if( fm(i)%fmult < 0 ) t = -t*rho(pbl%i%icl)
+
+    multiplier = t
+    if ( fm(i)%icx == 1 ) multiplier = multiplier*erg
+    if ( fm(i)%intrpol /= 0 ) multiplier = multiplier*dosef_fmesh(erg, i)
+
+    return
+  end subroutine dagmc_get_multiplier
+
+  !-----------------------------------------------------------------------------------------
+
@@ -1489,0 +1688,4 @@
+
+    ! DAGMC
+    real(dknd) :: dagmc_multiplier
+
@@ -1502,0 +1705,13 @@
+    ! DAGMC: update multipliers if any dagmc mesh tallies exist
+    if ( enable_dag_tallies ) then
+      do i = 1, nmesh
+        call dagmc_get_multiplier(i, erg, dagmc_multiplier)
+        call dagmc_update_multiplier(i, dagmc_multiplier)
+      enddo
+    endif
+
+    ! DAGMC: compute scores for all dagmc mesh tallies
+    if ( enable_dag_track_tallies ) then
+       call dagmc_fmesh_score(ipt, x, y, z, u, v, w, erg, wgt, d, pbl%i%icl)
+    endif
+
@@ -1511,0 +1727,5 @@
+      ! DAGMC: skip iteration if dagmc mesh tally
+      if ( fm(i)%icrd == 3 ) then
+        cycle
+      endif
+
@@ -2868,0 +3089,5 @@
+    ! DAGMC: write data to file for all dagmc mesh tallies
+    if ( enable_dag_tallies ) then
+      call dagmc_fmesh_print(sp_norm)
+    endif
+
@@ -2870,0 +3096,5 @@
+      ! DAGMC: skip iteration if dagmc mesh tally
+      if( fm(j)%icrd == 3 ) then
+        cycle
+      endif
+
@@ -4076,0 +4307,7 @@
+
+    ! DAGMC: setup up dagmc mesh tallies based on fmesh index i
+    do i = 1,nmesh
+      if( fm(i)%icrd == 3 ) then
+        call dagmc_setup_mesh_tally(i)
+      endif
+    enddo
diff -rN '--unified=0' Source/src/history_neutral_high.F90 Source_dagmc/src/history_neutral_high.F90
--- Source/src/history_neutral_high.F90
+++ Source_dagmc/src/history_neutral_high.F90
@@ -160 +160,2 @@
-      if( D <= zero ) then  !  Review the need for this test.
+      ! DAGMC: use < instead of <=
+      if( D < zero ) then  !  Review the need for this test.
diff -rN '--unified=0' Source/src/hstory.F90 Source_dagmc/src/hstory.F90
--- Source/src/hstory.F90
+++ Source_dagmc/src/hstory.F90
@@ -12 +12 @@
-  use fmesh_mod, only: nmesh
+  use fmesh_mod, only: nmesh, enable_dag_collision_tallies
@@ -25,0 +26 @@
+  use dagmc_mod, only: isdgmc
@@ -166 +167,2 @@
-        if( lca(pbl%i%icl) < 0 ) then
+        ! DAGMC: only do this when running in non-CAD mode
+        if( ( lca(pbl%i%icl) < 0 ) .and. (isdgmc == 0 ) ) then
@@ -215 +217,2 @@
-            call track(pbl%i%icl)
+            ! DAGMC: only call track here if in normal mode (NOT in CAD mode)
+            if ( isdgmc == 0 ) call track(pbl%i%icl)
@@ -324,0 +328,8 @@
+                    ! DAGMC: In CAD mode, call DAGMC before forcing collision
+                    if ( isdgmc == 1 ) then
+                      if ( lca(pbl%i%icl) < 0 ) call chkcel(pbl%i%icl, 3, j)
+                      call dagmc_setdis(huge_float)
+                      call track(pbl%i%icl)
+                      if ( kdb /= 0 ) exit HISTORY_LOOP
+                    endif
+
@@ -419,0 +431,9 @@
+          ! DAGMC: In CAD mode, get particle information
+          if ( isdgmc == 1 ) then
+            if ( lca(pbl%i%icl) < 0 ) call chkcel(pbl%i%icl, 3, j)
+            D = min(pbl%r%dcs, pbl%r%dxl, pbl%r%dtc, deb, dw)
+            call dagmc_setdis(D)
+            call track(pbl%i%icl)
+            if ( kdb /= 0 ) exit HISTORY_LOOP
+          endif
+
@@ -936 +956,5 @@
-
+    ! DAGMC: Collision Tally
+    if ( enable_dag_collision_tallies ) then
+      call dagmc_collision_score(pbl%i%ipt, pbl%r%x, pbl%r%y, pbl%r%z, &
+                                 pbl%r%erg, pbl%r%wgt, ple, pbl%i%icl)
+    endif
@@ -958,0 +983,3 @@
+          ! DAGMC
+          if( isdgmc == 1 ) call dagmc_particle_terminate()
+
diff -rN '--unified=0' Source/src/igeom.F90 Source_dagmc/src/igeom.F90
--- Source/src/igeom.F90
+++ Source_dagmc/src/igeom.F90
@@ -13,0 +14 @@
+  use dagmc_mod, only : isdgmc
@@ -110,0 +112,3 @@
+  ! DAGMC: only call this when running in normal (non-CAD) mode
+  if ( isdgmc == 1 ) return
+
diff -rN '--unified=0' Source/src/imcn.F90 Source_dagmc/src/imcn.F90
--- Source/src/imcn.F90
+++ Source_dagmc/src/imcn.F90
@@ -27,0 +28 @@
+  use dagmc_mod, only : isdgmc, dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode
@@ -1509,0 +1511,5 @@
+
+    ! Initialize DAGMC
+    if ( isdgmc == 1 ) then  ! set DAGMC parameters from idum & rdum
+      call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode)
+    endif
diff -rN '--unified=0' Source/src/itally.F90 Source_dagmc/src/itally.F90
--- Source/src/itally.F90
+++ Source_dagmc/src/itally.F90
@@ -30,0 +31 @@
+  use dagmc_mod, only : isdgmc
@@ -213,0 +215,7 @@
+
+        ! DAGMC: If in CAD mode, skip up until line prior to marker 40
+        if ( isdgmc == 1 ) then
+          itds(li+i) = k
+          goto 40
+        endif
+
diff -rN '--unified=0' Source/src/main.F90 Source_dagmc/src/main.F90
--- Source/src/main.F90
+++ Source_dagmc/src/main.F90
@@ -57 +57 @@
-    & iofiles, outp
+    & iofiles, outp, gcad, lcad, fcad, ftol
@@ -60,0 +61 @@
+  use dagmc_mod, only : isdgmc, dagmc_geom_file_mode, DGFM_READ
@@ -63 +64 @@
-  use mcnp_env, only : HDPTH0, KOD, LODDAT, VER
+  use mcnp_env, only : hdpth0, kod, loddat, ver
@@ -75,0 +77 @@
+  use dagmc_mod,           only: init_dagmc, dagmc_version_heading
@@ -184,0 +187,17 @@
+  ! DAGMC: initialize a DAGMC run if specified
+  if ( gcad%runtime_name /= ' ' ) then
+    isdgmc = 1
+    if (mcnp_opt_mpi) dagmc_geom_file_mode = DGFM_READ;
+  else
+    ! Error checking for user specifying worthless files
+    if( lcad%runtime_name /= ' ' ) then
+      call expire(0, 'main', 'CAD list file specified without a geometry file.')
+    endif
+    if( fcad%runtime_name /= ' ' ) then
+      call expire(0, 'main', 'CAD facet file specified without a geometry file.')
+    endif
+    if( ftol%runtime_name /= ' ' ) then
+      call expire(0, 'main', 'Facet tolerance specified without a geometry file.')
+    endif
+  endif
+
@@ -242,0 +262,4 @@
+  ! DAGMC
+  if ( isdgmc == 1 ) then
+    call init_dagmc
+  endif
@@ -266,0 +290,2 @@
+  ! DAGMC
+  if (isdgmc == 1) call dagmc_version_heading( iuo )
diff -rN '--unified=0' Source/src/mcnp_env.F90 Source_dagmc/src/mcnp_env.F90
--- Source/src/mcnp_env.F90
+++ Source_dagmc/src/mcnp_env.F90
@@ -0,0 +1,78 @@
+
+  module mcnp_env
+    !
+    ! code & environment info for mcnp
+    !
+
+    character(len=8), parameter, public ::  kod            = KODE
+    character(len=5), parameter, public ::  ver            = VERS
+    character(len=20),parameter, public ::  thread         = THREAD
+    character(len=20),parameter, public ::  thread_version = TVERS
+    character(len=8), parameter, public ::  loddat         = LODDAT
+    character(len=*), parameter, public ::  hdpth0 &
+      & = 'DATAPATH must be set by user'
+
+    public ::  print_build_info
+  CONTAINS
+    subroutine print_build_info( iunit )
+      integer, intent(in) :: iunit
+
+      write(iunit,*) '  +--------------------------------------------------------------------'
+      write(iunit,*) '  | mcnp6 build information:'
+      write(iunit,*) '  |'
+      write(iunit,*) '  | This executable was built with a custom CMake build, not'
+      write(iunit,*) '  | the build system from the discs supplied by RSICC. See'
+      write(iunit,*) '  | https://github.com/svalinn/DAGMC for more information.'
+      write(iunit,*) '  |'
+      write(iunit,*) '  |   user          = ', ENV_USER
+      write(iunit,*) '  |   host          = ', ENV_HOST
+      write(iunit,*) '  |   OS            = ', ENV_OS
+      write(iunit,*) '  |   date          = ', ENV_DATE
+      write(iunit,*) '  |   time          = ', ENV_TIME
+      write(iunit,*) '  |   CONFIG        = '
+      write(iunit,*) '  |   f90           = ', ENV_F90
+      write(iunit,*) '  |   f90 version   = ', ENV_F90_VERS
+      write(iunit,*) '  |   cc            = ', ENV_CC
+      write(iunit,*) '  |   cc  version   = ', ENV_CC_VERS
+      write(iunit,*) '  |   c++           = ', ENV_CXX
+      write(iunit,*) '  |   c++ version   = ', ENV_CXX_VERS
+#ifdef OMP
+      write(iunit,*) '  |   OpenMP        = yes'
+#else
+      write(iunit,*) '  |   OpenMP        = no'
+#endif
+#ifdef MPI
+      write(iunit,*) '  |   MPI           = yes'
+      write(iunit,*) '  |   MPI_ROOT      = ', ENV_MPI_ROOT
+#else
+      write(iunit,*) '  |   MPI           = no'
+      write(iunit,*) '  |   MPI_ROOT      = '
+#endif
+      write(iunit,*) '  |   code          = ', KODE
+      write(iunit,*) '  |   version       = ', VERS
+      write(iunit,*) '  |   thread name   = ', THREAD
+      write(iunit,*) '  |   thread number = ', TVERS
+      write(iunit,*) '  |   datapath      = DATAPATH must be set by user'
+      write(iunit,*) '  |   fpp defs      = '
+      write(iunit,*) '  |                 = ', COMPDEF_0
+      write(iunit,*) '  |                 = ', COMPDEF_1
+      write(iunit,*) '  |                 = ', COMPDEF_2
+      write(iunit,*) '  |                 = ', COMPDEF_3
+      write(iunit,*) '  |                 = ', COMPDEF_4
+      write(iunit,*) '  |                 = ', COMPDEF_5
+      write(iunit,*) '  |                 = ', COMPDEF_6
+      write(iunit,*) '  |                 = ', COMPDEF_7
+      write(iunit,*) '  |                 = ', COMPDEF_8
+      write(iunit,*) '  |                 = ', COMPDEF_9
+      write(iunit,*) '  |                 = ', COMPDEF_10
+      write(iunit,*) '  |                 = ', COMPDEF_11
+      write(iunit,*) '  |                 = ', COMPDEF_12
+      write(iunit,*) '  |                 = ', COMPDEF_13
+      write(iunit,*) '  |                 = ', COMPDEF_14
+      write(iunit,*) '  |                 = ', COMPDEF_15
+      write(iunit,*) '  |                 = ', COMPDEF_16
+      write(iunit,*) '  |                 = ', COMPDEF_17
+
+      write(iunit,*) '  +--------------------------------------------------------------------'
+    end subroutine print_build_info
+  end module mcnp_env
diff -rN '--unified=0' Source/src/mcnp_input.F90 Source_dagmc/src/mcnp_input.F90
--- Source/src/mcnp_input.F90
+++ Source_dagmc/src/mcnp_input.F90
@@ -43 +43 @@
-  integer,parameter, public :: nkcd  = 153                != Number of input card types
+  integer,parameter, public :: nkcd  = 154                != Number of input card types
@@ -290,0 +291,5 @@
+
+  ! DAGMC card keywords, input values
+    character(len=18), dimension(4), parameter, public :: &
+      & hdagmc = (/ 'check_src_cell    ', 'usecad            ', &
+      &             'distlimit         ', 'overlap_thickness ' /)
@@ -533,0 +539,2 @@
+    ! DAGMC cards
+    cnm(154) = 'dagmc'; krq(:,154) = (/ 0,0, 0,0, 0,              12,0 /)
diff -rN '--unified=0' Source/src/mcnp_iofiles.F90 Source_dagmc/src/mcnp_iofiles.F90
--- Source/src/mcnp_iofiles.F90
+++ Source_dagmc/src/mcnp_iofiles.F90
@@ -62 +62,5 @@
-    & dumn2
+    & dumn2  ,&
+    & gcad   ,& ! gcad    - DAGMC geometry input file (CAD or facets)
+    & lcad   ,& ! lcad    - DAGMC input log file
+    & fcad   ,& ! fcad    - DAGMC facets output file
+    & ftol      ! ftol    - DAGMC faceting tolerance
@@ -113,0 +118,4 @@
+    gcad    => iofiles(26)  ! DAGMC
+    lcad    => iofiles(27)  ! DAGMC
+    fcad    => iofiles(28)  ! DAGMC
+    ftol    => iofiles(29)  ! DAGMC
@@ -140,0 +149,4 @@
+    gcad    = mcnp_iofile( 0, "" , "gcad"           ) ! DAGMC
+    lcad    = mcnp_iofile( 0, "" , "lcad"           ) ! DAGMC
+    fcad    = mcnp_iofile( 0, "" , "fcad"           ) ! DAGMC
+    ftol    = mcnp_iofile( 0, "" , "ftol"           ) ! DAGMC
diff -rN '--unified=0' Source/src/mcnp_params.F90 Source_dagmc/src/mcnp_params.F90
--- Source/src/mcnp_params.F90
+++ Source_dagmc/src/mcnp_params.F90
@@ -444 +444,2 @@
-    &  iuksen  = 78      != I/O unit for keff sensitivity output file
+    &  iuksen  = 78,  &  != I/O unit for keff sensitivity output file
+    &  iulc    = 79      != I/O unit for DAGMC log file
diff -rN '--unified=0' Source/src/mcnp_storage.F90 Source_dagmc/src/mcnp_storage.F90
--- Source/src/mcnp_storage.F90
+++ Source_dagmc/src/mcnp_storage.F90
@@ -63,5 +63,2 @@
-#FPP_TEMPLATE_BEGIN
-#FPP_TEMPLATE <name> = r8;         r4;         i8;             i4;             i1
-#FPP_TEMPLATE <type> = real(DKND); real(RKND); integer(I8KND); integer(I4KND); integer(I1KND)
-   !================================================================ <name> =======
-   subroutine mcnp_alloc_<name>_1( name, array, lower1,upper1 )
+   !================================================================ r8 =======
+   subroutine mcnp_alloc_r8_1( name, array, lower1,upper1 )
@@ -70 +67 @@
-     <type>, allocatable, intent(inout) :: array( : )
+     real(DKND), allocatable, intent(inout) :: array( : )
@@ -77 +74 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_1', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_1', name )
@@ -79,2 +76,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_1
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_1
@@ -82 +79 @@
-   subroutine mcnp_alloc_<name>_2( name, array, lower1,upper1, lower2,upper2 )
+   subroutine mcnp_alloc_r8_2( name, array, lower1,upper1, lower2,upper2 )
@@ -85 +82 @@
-     <type>, allocatable, intent(inout) :: array( :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, : )
@@ -93 +90 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_2', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_2', name )
@@ -95,2 +92,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_2
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_2
@@ -98 +95 @@
-   subroutine mcnp_alloc_<name>_3( name, array, lower1,upper1, lower2,upper2,  &
+   subroutine mcnp_alloc_r8_3( name, array, lower1,upper1, lower2,upper2,  &
@@ -102 +99 @@
-     <type>, allocatable, intent(inout) :: array( :, :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, :, : )
@@ -111 +108 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_3', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_3', name )
@@ -113,2 +110,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_3
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_3
@@ -116 +113 @@
-   subroutine mcnp_alloc_<name>_4( name, array, lower1,upper1, lower2,upper2,  &
+   subroutine mcnp_alloc_r8_4( name, array, lower1,upper1, lower2,upper2,  &
@@ -120 +117 @@
-     <type>, allocatable, intent(inout) :: array( :, :, :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, :, :, : )
@@ -131 +128 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_4', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_4', name )
@@ -133,2 +130,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_4
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_4
@@ -136 +133 @@
-   subroutine mcnp_alloc_<name>_5( name, array, lower1,upper1, lower2,upper2,  &
+   subroutine mcnp_alloc_r8_5( name, array, lower1,upper1, lower2,upper2,  &
@@ -141 +138 @@
-     <type>, allocatable, intent(inout) :: array( :, :, :, :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, :, :, :, : )
@@ -153 +150 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_5', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_5', name )
@@ -155,2 +152,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_5
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_5
@@ -158 +155 @@
-   subroutine mcnp_alloc_<name>_6( name, array, lower1,upper1, lower2,upper2,  &
+   subroutine mcnp_alloc_r8_6( name, array, lower1,upper1, lower2,upper2,  &
@@ -163 +160 @@
-     <type>, allocatable, intent(inout) :: array( :, :, :, :, :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, :, :, :, :, : )
@@ -176 +173 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_6', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_6', name )
@@ -178,2 +175,2 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_6
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_6
@@ -181 +178 @@
-   subroutine mcnp_alloc_<name>_7( name, array, lower1,upper1, lower2,upper2,  &
+   subroutine mcnp_alloc_r8_7( name, array, lower1,upper1, lower2,upper2,  &
@@ -187 +184 @@
-     <type>, allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
+     real(DKND), allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
@@ -202 +199 @@
-       call get_mem_alloc_error( 'mcnp_alloc_<name>_7', name )
+       call get_mem_alloc_error( 'mcnp_alloc_r8_7', name )
@@ -204,2 +201,570 @@
-     array = <name>_zero
-   end subroutine mcnp_alloc_<name>_7
+     array = r8_zero
+   end subroutine mcnp_alloc_r8_7
+   !-----------------------------------------------------------------------------
+
+   !================================================================ r4 =======
+   subroutine mcnp_alloc_r4_1( name, array, lower1,upper1 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( : )
+     integer,             intent(in)    :: lower1, upper1 
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_1', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_1
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_2( name, array, lower1,upper1, lower2,upper2 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_2', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_2
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_3( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_3', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_3
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_4( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_4', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_4
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_5( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_5', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_5
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_6( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_6', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_6
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_r4_7( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6,  &
+     &                                          lower7,upper7 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     real(RKND), allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer,             intent(in)    :: lower7, upper7
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6, &
+       &                  lower7:upper7 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_r4_7', name )
+     endif
+     array = r4_zero
+   end subroutine mcnp_alloc_r4_7
+   !-----------------------------------------------------------------------------
+
+   !================================================================ i8 =======
+   subroutine mcnp_alloc_i8_1( name, array, lower1,upper1 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( : )
+     integer,             intent(in)    :: lower1, upper1 
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_1', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_1
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_2( name, array, lower1,upper1, lower2,upper2 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_2', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_2
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_3( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_3', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_3
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_4( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_4', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_4
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_5( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_5', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_5
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_6( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_6', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_6
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i8_7( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6,  &
+     &                                          lower7,upper7 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I8KND), allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer,             intent(in)    :: lower7, upper7
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6, &
+       &                  lower7:upper7 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i8_7', name )
+     endif
+     array = i8_zero
+   end subroutine mcnp_alloc_i8_7
+   !-----------------------------------------------------------------------------
+
+   !================================================================ i4 =======
+   subroutine mcnp_alloc_i4_1( name, array, lower1,upper1 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( : )
+     integer,             intent(in)    :: lower1, upper1 
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_1', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_1
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_2( name, array, lower1,upper1, lower2,upper2 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_2', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_2
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_3( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_3', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_3
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_4( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_4', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_4
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_5( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_5', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_5
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_6( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_6', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_6
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i4_7( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6,  &
+     &                                          lower7,upper7 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I4KND), allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer,             intent(in)    :: lower7, upper7
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6, &
+       &                  lower7:upper7 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i4_7', name )
+     endif
+     array = i4_zero
+   end subroutine mcnp_alloc_i4_7
+   !-----------------------------------------------------------------------------
+
+   !================================================================ i1 =======
+   subroutine mcnp_alloc_i1_1( name, array, lower1,upper1 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( : )
+     integer,             intent(in)    :: lower1, upper1 
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_1', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_1
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_2( name, array, lower1,upper1, lower2,upper2 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2 ),    stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_2', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_2
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_3( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_3', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_3
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_4( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_4', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_4
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_5( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_5', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_5
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_6( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_6', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_6
+   !-----------------------------------------------------------------------------
+   subroutine mcnp_alloc_i1_7( name, array, lower1,upper1, lower2,upper2,  &
+     &                                          lower3,upper3, lower4,upper4,  &
+     &                                          lower5,upper5, lower6,upper6,  &
+     &                                          lower7,upper7 )
+     implicit none
+     character(len=*),    intent(in)    :: name
+     integer(I1KND), allocatable, intent(inout) :: array( :, :, :, :, :, :, : )
+     integer,             intent(in)    :: lower1, upper1
+     integer,             intent(in)    :: lower2, upper2
+     integer,             intent(in)    :: lower3, upper3
+     integer,             intent(in)    :: lower4, upper4
+     integer,             intent(in)    :: lower5, upper5
+     integer,             intent(in)    :: lower6, upper6
+     integer,             intent(in)    :: lower7, upper7
+     integer :: ierr
+
+     if( allocated(array) )  deallocate(array)
+     allocate(     array( lower1:upper1, lower2:upper2, lower3:upper3, &
+       &                  lower4:upper4, lower5:upper5, lower6:upper6, &
+       &                  lower7:upper7 ),  stat=ierr )
+     if( ierr /=0 ) then
+       call get_mem_alloc_error( 'mcnp_alloc_i1_7', name )
+     endif
+     array = i1_zero
+   end subroutine mcnp_alloc_i1_7
@@ -208 +772,0 @@
-#FPP_TEMPLATE_END
diff -rN '--unified=0' Source/src/msgcon.F90 Source_dagmc/src/msgcon.F90
--- Source/src/msgcon.F90
+++ Source_dagmc/src/msgcon.F90
@@ -81,0 +82 @@
+  use dagmc_mod,           only: dagmc_msgbcast
@@ -316,0 +318,4 @@
+
+  ! DAGMC
+  write(jtty,*) "master sending DAGMC information..."
+  call dagmc_msgbcast
diff -rN '--unified=0' Source/src/msgtsk.F90 Source_dagmc/src/msgtsk.F90
--- Source/src/msgtsk.F90
+++ Source_dagmc/src/msgtsk.F90
@@ -76,0 +77 @@
+  use dagmc_mod,         only: dagmc_msgbcast
@@ -257,0 +259,2 @@
+  ! DAGMC
+  call dagmc_msgbcast
diff -rN '--unified=0' Source/src/namchg.F90 Source_dagmc/src/namchg.F90
--- Source/src/namchg.F90
+++ Source_dagmc/src/namchg.F90
@@ -10,0 +11 @@
+  use dagmc_mod, only : isdgmc
@@ -35,0 +37,2 @@
+  ! DAGMC: Need to change some of these conditionals, no bounding
+  !        surfaces exist in CAD mode, handle as regular surface
@@ -37 +40 @@
-  if( mm==2 ) then
+  if( ( mm==2 ) .or. ( ( mm == 3) .and. ( isdgmc == 1 ) ) ) then
@@ -42 +45 @@
-  elseif( mm==3 ) then
+  elseif( ( mm==3 ) .and. ( isdgmc == 0 ) ) then
diff -rN '--unified=0' Source/src/newcel.F90 Source_dagmc/src/newcel.F90
--- Source/src/newcel.F90
+++ Source_dagmc/src/newcel.F90
@@ -17,0 +18 @@
+  use dagmc_mod, only : isdgmc
@@ -52,0 +54,14 @@
+  ! DAGMC: move this to the top
+  found_surface_crossed = .false.
+
+  ! DAGMC: In CAD mode, call MOAB version of this
+  if ( isdgmc == 1 ) then
+    if ( cs /= 0 ) call angl( cs, ang )
+    call dagmcnewcel(pbl%i%jsu, pbl%i%icl, pbl%i%iap)
+    if ( mxa == -1 ) then
+      kdb = 1
+    else
+      found_surface_crossed = .true.
+    endif
+  endif
+
@@ -84 +98,0 @@
-  found_surface_crossed = .false.
diff -rN '--unified=0' Source/src/nextit.F90 Source_dagmc/src/nextit.F90
--- Source/src/nextit.F90
+++ Source_dagmc/src/nextit.F90
@@ -55 +55 @@
-    & ri_mopt, ric_mopt, ris_mopt
+    & ri_mopt, ric_mopt, ris_mopt, hdagmc
@@ -64,0 +65 @@
+  use dagmc_mod, only: dagmc_srcmode, dagmc_usecad, dagmc_distlimit, dagmc_overlap_thickness
@@ -2675,0 +2677,3 @@
+              ! DAGMC
+              elseif( hitm(1:3) == 'dag' ) then
+                fm(nmesh)%icrd=3
@@ -3464,0 +3469,21 @@
+
+      case( 154 )
+        !  >>>>>  DAGMC parameters                                                                dagmc
+        !  Modeled after RAND (99)
+        !  m1c=index of current dagmc keyword.
+        if( m1c == 0 ) then
+          if( index(',=', hitm(1:1)) == 0 ) then
+            do m1c = 1,4
+              if( hitm(1:18) == hdagmc(m1c) ) return
+            enddo
+            m1c = 0
+          endif
+        else
+          if( index(',=',hitm(1:1))==0 ) then
+            if( m1c==1 .and. ( hitm(1:2) == 'of' .or. hitm(1:2) == 'no' ) )  dagmc_srcmode = 1
+            if( m1c==2 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye' ) )  dagmc_usecad = 1
+            if( m1c==3 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye' ) )  dagmc_distlimit = 1
+            if( m1c==4 )  dagmc_overlap_thickness = ritm
+            m1c = 0
+          endif
+        endif
diff -rN '--unified=0' Source/src/oldcrd.F90 Source_dagmc/src/oldcrd.F90
--- Source/src/oldcrd.F90
+++ Source_dagmc/src/oldcrd.F90
@@ -28,0 +29 @@
+  use dagmc_mod, only : isdgmc
@@ -79 +80,2 @@
-      if( lca(mxa) == nlja + 1 ) then
+      ! DAGMC: In CAD mode, cells should have no surfaces
+      if( ( lca(mxa) == nlja + 1 ) .and. ( isdgmc == 0 ) ) then
@@ -89,0 +92,3 @@
+    ! DAGMC: Break out of subroutine here in CAD mode
+    if ( isdgmc == 1 ) return
+
@@ -1456,0 +1462,7 @@
+
+        ! DAGMC: skip handling imesh/jmesh/kmesh/orig when geom=DAG; check emesh before jump
+        if( ifmsh(13) == 0 ) then
+          ientmp(1:ifmsh(12)) = 1
+        endif
+        if( fm(nmesh)%icrd==3 ) goto 4900
+
@@ -1469,3 +1481,4 @@
-        if( ifmsh(13) == 0 ) then
-          ientmp(1:ifmsh(12)) = 1
-        endif
+        ! DAGMC: comment this out
+        ! if( ifmsh(13) == 0 ) then
+        !   ientmp(1:ifmsh(12)) = 1
+        ! endif
@@ -1647,0 +1661 @@
+4900 continue ! DAGMC jump target
diff -rN '--unified=0' Source/src/pass0.F90 Source_dagmc/src/pass0.F90
--- Source/src/pass0.F90
+++ Source_dagmc/src/pass0.F90
@@ -14,0 +15 @@
+  use dagmc_mod, only : isdgmc, lcadrd
@@ -27,0 +29,3 @@
+
+  ! DAGMC: For CAD mode, read cell/surface cards from log file
+  if ( isdgmc == 1 ) call lcadrd
diff -rN '--unified=0' Source/src/pblcom.F90 Source_dagmc/src/pblcom.F90
--- Source/src/pblcom.F90
+++ Source_dagmc/src/pblcom.F90
@@ -329,0 +330 @@
+    use dagmc_mod, only : isdgmc
@@ -354,0 +356,5 @@
+    ! DAGMC: save this particle's ray history
+    if (isdgmc == 1) then
+      call dagmc_savpar(n)
+    endif
+
@@ -522,0 +529 @@
+    use dagmc_mod, only : isdgmc
@@ -538,0 +546,5 @@
+
+    ! DAGMC: Restore the ray history associated with this particle
+    if ( isdgmc == 1 ) then
+      call dagmc_getpar(n)
+    endif
diff -rN '--unified=0' Source/src/reflec.F90 Source_dagmc/src/reflec.F90
--- Source/src/reflec.F90
+++ Source_dagmc/src/reflec.F90
@@ -16,0 +17 @@
+  use dagmc_mod, only : isdgmc
@@ -122,0 +124,2 @@
+  ! DAGMC:
+  if( isdgmc == 1 ) call dagmc_surf_reflection( pbl%r%u, pbl%r%v, pbl%r%w, 0 )
diff -rN '--unified=0' Source/src/sourcb.F90 Source_dagmc/src/sourcb.F90
--- Source/src/sourcb.F90
+++ Source_dagmc/src/sourcb.F90
@@ -21,0 +22 @@
+  use dagmc_mod, only : isdgmc, dagmc_srcmode
@@ -869 +870,6 @@
-           call chkcel(ji,0,j)
+          ! DAGMC: if dagmc_srcmode is on, skip chkcel and assume particle is in user-specified cell
+          if( isdgmc==1 .and. dagmc_srcmode==1 ) then
+            j = 0
+          else
+            call chkcel(ji,0,j)
+          endif
diff -rN '--unified=0' Source/src/startp.F90 Source_dagmc/src/startp.F90
--- Source/src/startp.F90
+++ Source_dagmc/src/startp.F90
@@ -55,0 +56 @@
+  use dagmc_mod,      only: isdgmc
@@ -137,0 +139,6 @@
+
+  ! DAGMC: nbnk = 0
+  if ( isdgmc == 1 ) then
+    call dagmc_bank_clear
+  endif
+
diff -rN '--unified=0' Source/src/tally.F90 Source_dagmc/src/tally.F90
--- Source/src/tally.F90
+++ Source_dagmc/src/tally.F90
@@ -35,0 +36 @@
+  use dagmc_mod, only : isdgmc
@@ -575,0 +577,4 @@
+
+    ! DAGMC: If in CAD mode, make sure distance to physics collision is initialized
+    if ( isdgmc == 1 ) call dagmc_setdis(huge_float)
+
diff -rN '--unified=0' Source/src/track.F90 Source_dagmc/src/track.F90
--- Source/src/track.F90
+++ Source_dagmc/src/track.F90
@@ -19,0 +20,2 @@
+  use varcom,         only: nps
+  use dagmc_mod,      only: isdgmc
@@ -63,0 +66,7 @@
+  ! DAGMC: If in CAD mode, call DAGMC version of track instead
+  if ( isdgmc == 1 ) then
+    call dagmctrack(icell, pbl%r%u, pbl%r%v, pbl%r%w, pbl%r%x, pbl%r%y, pbl%r%z, &
+     &              huge_float, pbl%r%dls, jap, pbl%i%jsu, nps)
+    if ( pbl%r%dls == huge_float ) kdb = 2
+    return
+  endif
diff -rN '--unified=0' Source/src/transm.F90 Source_dagmc/src/transm.F90
--- Source/src/transm.F90
+++ Source_dagmc/src/transm.F90
@@ -17,0 +18 @@
+  use dagmc_mod, only : isdgmc
@@ -138,0 +140,3 @@
+
+    ! DAGMC: If in CAD mode, call dagmc_setdis first
+    if ( isdgmc == 1 ) call dagmc_setdis( dd - sd )
diff -rN '--unified=0' Source/src/volume.F90 Source_dagmc/src/volume.F90
--- Source/src/volume.F90
+++ Source_dagmc/src/volume.F90
@@ -8 +8 @@
-  use fixcom, only : ink, msd, mxa, ntal, mipt_mode, mipt_locct
+  use fixcom, only : ink, msd, mxa, ntal, mipt_mode, mipt_locct, mxj
@@ -24,0 +25 @@
+  use dagmc_mod, only : isdgmc
@@ -46,0 +48,5 @@
+  ! DAGMC: In CAD mode, circumvent most of this function and call DAGMC version
+  if (isdgmc == 1) then
+    call dagmcvolume(mxa, vols, mxj, aras)
+    goto 260
+  endif
