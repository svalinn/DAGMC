diff -rupN Source-orig/src/angl.F90 Source/src/angl.F90
--- Source-orig/src/angl.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/angl.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,11 +9,19 @@ function angl()
   ! Modules used:
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: ij = 0 ! local jsu error counter
   integer :: is = 0 ! local surface error counter
 
+  ! DAGMC: In CAD mode, circumvent entire function and call DAGMC version instead
+  if (isdgmc == 1) then
+     call dagmcangl(jsu,xxx,yyy,zzz,ang)
+     angl=max(-one,min(one,ang(1)*uuu+ang(2)*vvv+ang(3)*www))
+     return
+  endif
+
   ! initialize angl so that angl doesn't get underflow or overflow
   angl=one
 
diff -rupN Source-orig/src/bankit.F90 Source/src/bankit.F90
--- Source-orig/src/bankit.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/bankit.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,6 +9,7 @@ subroutine bankit(m)
   use mcnp_global
   use mcnp_debug
   use phtvr_mod, only: phtvr_bankit_flag
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer, parameter :: nx = nbmx/2
@@ -50,6 +51,11 @@ contains
       endif
     endif
 
+    ! DAGMC: 
+    if ( isdgmc == 1 ) then    
+       call dagmc_bank_push( nbnk )
+    endif
+
     ! Make room for the new particle if necessary.
     if( jbnk>=nbmx ) then
 
@@ -172,6 +178,12 @@ contains
     ! Description
     ! m=100 -- Retrieve a particle from the bank.
     !
+
+    ! DAGMC: 
+    if ( isdgmc == 1 ) then    
+       call dagmc_bank_usetop(  )
+    endif
+
 130 continue
   ! Fetch a block from the backup file if necessary.
     if( jbnk==0 ) then
@@ -238,6 +250,10 @@ contains
     endif
 
     if( npa<=1 ) then
+       ! DAGMC: 
+       if ( isdgmc == 1 ) then    
+          call dagmc_bank_pop( nbnk  )
+       endif
       nbnk = nbnk-1
       jbnk = jbnk-1
       mbb = mb
diff -rupN Source-orig/src/celsrf.F90 Source/src/celsrf.F90
--- Source-orig/src/celsrf.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/celsrf.F90	2016-03-18 16:28:36.514327791 -0500
@@ -10,6 +10,7 @@ subroutine celsrf
   use mcnp_debug
   use mcnp_input
   use erprnt_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character hj(2,3)*10, hl*5, hp*130, hq*2, ht*4
@@ -307,6 +308,10 @@ subroutine celsrf
 470 continue
   jp = 0
   DO_500: do j=1,mxj
+     
+    ! DAGMC: Skip tihs loop if in CAD mode
+     if (isdgmc == 1) exit
+
     if( idns(j)/=0 )  cycle DO_500
     if( ksm(j)/=0  )  cycle DO_500
     if( ksu(j)>0   )  jp=1
diff -rupN Source-orig/src/chekit.F90 Source/src/chekit.F90
--- Source-orig/src/chekit.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/chekit.F90	2016-03-18 16:28:36.514327791 -0500
@@ -1095,6 +1095,7 @@ subroutine chekit
         endif
       enddo
       if(      hitm(1:3)/='xyz' .and. hitm(1:3)/='rec'  &
+        & .and.hitm(1:3)/='dag'  &  ! DAGMC option  
         & .and.hitm(1:3)/='rzt' .and. hitm(1:3)/='cyl'  &
         & .and.hitm(1:3)/='col' .and. hitm(1:3)/='ij '  &
         & .and.hitm(1:3)/='ik ' .and. hitm(1:3)/='jk'   &
diff -rupN Source-orig/src/chkcel.F90 Source/src/chkcel.F90
--- Source-orig/src/chkcel.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/chkcel.F90	2016-03-18 16:28:36.514327791 -0500
@@ -20,11 +20,18 @@ subroutine chkcel(i1,m,j)
   ! Modules used:
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: j,k,ie=0
   real(dknd) :: xyz_save(3), uvw_save(3)
 
+  ! DAGMC: In CAD mode, circumvent this function and call DAGMC version instead
+  if ( isdgmc == 1 .and. (m == 0 .or. m==2) ) then
+     call dagmcchkcel(uuu,vvv,www,xxx,yyy,zzz,i1,j)
+     return
+  endif
+  
   ! Do all surfaces of cell i1 or until mm is matched.
   j2 = abs(lca(i1))
   iL = j2-lca(i1)+m
diff -rupN Source-orig/src/dagmc_mod.F90 Source/src/dagmc_mod.F90
--- Source-orig/src/dagmc_mod.F90	1969-12-31 18:00:00.000000000 -0600
+++ Source/src/dagmc_mod.F90	2016-03-18 16:28:36.514327791 -0500
@@ -0,0 +1,254 @@
+module dagmc_mod
+
+  use mcnp_params
+  use pblcom, only: mpb
+
+  integer, parameter, public :: & ! named constant for file distribution mode
+     & DGFM_SEQ   = 0, &
+     & DGFM_READ  = 1, & 
+     & DGFM_BCAST = 2 
+
+  integer, save :: isdgmc 
+
+  integer, save :: dagmc_geom_file_mode = DGFM_SEQ  ! default to a distributed read
+
+  integer, save :: dagmc_srcmode = 0
+  integer, save :: dagmc_usecad  = 0
+  integer, save :: dagmc_distlimit = 0
+  
+  real(dknd), save :: dagmc_facet_tol
+  real(dknd), save :: dagmc_overlap_thickness
+  real(dknd), save :: dagmc_version
+  
+  integer, save :: dagmc_subversion
+
+  public :: &
+    &   lcadrd, &        ! read log file information
+    &   dagmc_msgput, &  ! share dagmc settings to slave tasks
+    &   dagmc_msgget    ! receive dagmc settings from master task
+
+contains
+
+  subroutine lcadrd
+    ! Description:
+    ! Reads in the CAD log file and "inserts" it at the header
+    ! of the input file.
+    
+    ! >>>>> Modules used
+    use mcnp_global
+    use mcnp_params
+    use mcnp_iofiles
+    
+    ! >>>>> Implict declaration of real variables as doubles
+    implicit real(dknd) (a-h,o-z)
+    
+    ! >>>>> Other variables
+    character(len=80)  :: hk          ! Character for line of file being read
+    integer, parameter :: ie = 70     ! I/O index of a scratch file
+    integer            :: it, iu = 0  ! Indices for nxtsym function
+    integer            :: ios = 0     ! IOSTAT for file reading
+    
+    ! >>>>> Initialize the scratch file and get to beginning of input file
+    open(ie,status='scratch')
+    rewind iui
+    
+    ! >>>>> Check if first line is message block, otherwise assume a title card
+    read(iui,'(a80)',end=1000) hk
+    call nxtsym(hk,' ',1,it,iu,1)
+    
+    if (hk(it:iu) == 'message:') then
+       ! Message block exists, read until blank line found
+       do
+          read(iui,'(a80)',end=1000) hk   ! Read in string: exception for eof
+          if (hk == ' ') exit             ! Terminate loop once blank line found 
+       enddo
+       ! Read in title card, for message block case
+       read(iui,'(a80)',end=1000) hk
+    endif
+    
+    ! Write title card to scratch file
+    write(ie,'(a80)') hk
+    
+    ! >>>>> Read in cell/surface cards from log
+    rewind iulc
+    do
+       read(iulc, '(a80)', iostat=ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line normally
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 2000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>> Read in rest of input file
+    ios = 0
+    do
+       read(iui, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(ie,'(a80)') hk     ! Write the line to scratch file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 3000                ! Exception for severe I/O error
+       endif
+    enddo
+    
+    ! >>>>> Echo back to new scratch input file
+    close(iui)
+    rewind ie
+    open(iui,status='scratch')
+    ios = 0
+    do      
+       read(ie, '(a80)', iostat = ios) hk
+       
+       ! Check for end of file or errors
+       if (ios == 0) then
+          write(iui,'(a80)') hk    ! Write the line in the scratch input file
+       elseif (ios < 0) then
+          exit                     ! Break loop at EOF
+       else
+          goto 4000                ! Exception for severe I/O error
+       endif
+       
+    enddo
+    
+    ! >>>>> Finish up
+    rewind iui
+    ! pass1 expects iui to be advanced beyond the title card, 
+    ! so read past the first line now
+    read(iui, '(a)')
+
+    close(ie)
+    return
+    
+    ! >>>>> Exceptions
+    ! End of File at header of input file
+1000 call expire(0,'lcadrd','unexpected eof in file '//inp)
+    return
+    ! Severe I/O error during reading of CAD log
+2000 call expire(0,'lcadrd','error during read of file '//lcad)
+    return
+    ! Severe I/O error during reading of CAD log
+3000 call expire(0,'lcadrd','error during read of file '//inp)
+    return
+    ! Severe I/O error during echo of scratch file to new input file
+4000 call expire(0,'lcadrd','error stitching input and CAD log')
+    return
+    
+  end subroutine lcadrd
+
+  subroutine dagmc_msgput
+
+    use messages, only : msg_put
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    call msg_put (isdgmc)
+    call msg_put (dagmc_geom_file_mode)
+    call msg_put (gcad)
+    call msg_put (ftol)
+    call msg_put (dagmc_srcmode)
+    call msg_put (dagmc_usecad)
+    call msg_put (dagmc_distlimit)
+    call msg_put (dagmc_overlap_thickness)
+    call msg_put (dagmc_facet_tol)
+    call msg_put (dagmc_version)
+
+  end subroutine dagmc_msgput
+
+  subroutine dagmc_msgget
+   
+    use messages, only : msg_get
+    use mcnp_iofiles, only: gcad, ftol
+    use fixcom, only : ntal
+    use mcnp_debug
+
+    implicit none
+
+    real(dknd) :: master_dagmc_version
+
+    call msg_get (isdgmc)
+    call msg_get (dagmc_geom_file_mode)
+    call msg_get (gcad)
+    call msg_get (ftol)
+    call msg_get (dagmc_srcmode)
+    call msg_get (dagmc_usecad)
+    call msg_get (dagmc_distlimit)
+    call msg_get (dagmc_overlap_thickness)
+    call msg_get (dagmc_facet_tol)
+    call msg_get (master_dagmc_version)
+
+    if ( isdgmc == 1 ) then
+       call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &           ftol//char(0),len_trim(ftol),      &
+          &           dagmc_geom_file_mode, dagmc_version, dagmc_subversion, mpb )
+       if (dagmc_version /= master_dagmc_version) then
+          ! errprt and fail!
+       end if
+       call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode )
+    end if
+
+  end subroutine dagmc_msgget
+  
+  subroutine init_dagmc
+
+     use mcnp_iofiles
+
+     ! Check to see if the CAD file exists, if not, abort
+     inquire( file = gcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD geometry file '//gcad// &
+             &            ' does not exist.')
+     endif
+     
+     ! initialize DAGMC, read geometry and initialize OBBTree
+     call dagmcinit(gcad//char(0),len_trim(gcad),      &
+          &         ftol//char(0),len_trim(ftol),      &
+          &         dagmc_geom_file_mode,dagmc_version, dagmc_subversion, mpb )
+
+
+     call dagmc_init_settings(dagmc_distlimit, dagmc_usecad, &
+                              dagmc_overlap_thickness, dagmc_facet_tol, dagmc_srcmode)
+
+     ! print version number message to terminal
+     call dagmc_version_heading(jtty)
+
+     ! write mesh file if requested
+     if ( len_trim(fcad) .gt. 0) then
+        call dagmcwritefacets(fcad//char(0),len_trim(fcad))     
+     endif
+
+
+     ! parse metadata and write input cards
+     call dagmcwritemcnp(lcad//char(0), len_trim(lcad))
+     
+     ! Check to ensure that the log file is written
+     inquire( file = lcad, exist = file_exists)
+     if (.not.file_exists) then
+        call expire(0,'main','CAD list file '//lcad// &
+             &             ' not written by DAGMC.')
+     endif
+     
+     ! Open the cad log file on the MCNP side
+     open( unit=iulc, file=lcad, status='old' )
+
+  end subroutine init_dagmc
+
+  ! write DagMC version number message to given file
+  subroutine dagmc_version_heading(o)
+    
+    integer :: o 
+
+     write(o,150) dagmc_version, dagmc_subversion
+150  format(1x,'This problem is using DAGMC version ',f8.3,' w/ DagMC r', i4)
+
+  end subroutine dagmc_version_heading
+
+end module dagmc_mod
diff -rupN Source-orig/src/dbmin.F90 Source/src/dbmin.F90
--- Source-orig/src/dbmin.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/dbmin.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,9 +9,21 @@ function dbmin()
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
+  ! DAGMC: Explicitly declare variable for return value for inter-language call
+  real(dknd) :: dbmin_retval = zero
+
+  ! DAGMC: In CAD mode, call MOAB version instead
+  if ( isdgmc == 1 ) then
+     call dagmcdbmin(icl,xxx,yyy,zzz,huge_float,dbmin_retval)
+     dbmin = dbmin_retval
+     return
+  endif
+
+
   dbmin = huge_float
   ic = icl
   x0 = xxx
diff -rupN Source-orig/src/echkcl.F90 Source/src/echkcl.F90
--- Source-orig/src/echkcl.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/echkcl.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,13 +9,23 @@ subroutine echkcl(j)
   ! at the level (levp) of the shortest distance to boundary.
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
   ! call regular chkcel for no repeated structures or lattices
   ! or if lev=levp (shortest distance is in level lev).
   if( junf==0 .or. lev==levp ) then
-    call  chkcel(icl,2,j)
+    if( isdgmc == 1 ) then
+       ! dagmc note: I'm not aware that lev/levp ever differ during dagmc execution,
+       !           : and I know that repeated structures are not involved,
+       !           : so I have not modified the other call to chkcel in this function.
+       !           : If I'm wrong, this same check should be added below.
+       call dagmcchkcel_by_angle( uuu, vvv, www, xxx, yyy, zzz, jsu, icl, j )
+       call dagmc_surf_reflection( uuu, vvv, www, 1 )
+    else
+       call  chkcel(icl,2,j)
+    endif
     return
   endif
    
diff -rupN Source-orig/src/electr.F90 Source/src/electr.F90
--- Source-orig/src/electr.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/electr.F90	2016-03-18 16:28:36.514327791 -0500
@@ -10,6 +10,7 @@ subroutine electron_history_4c3
   use mcnp_landau, only: esloss
   use fmesh_mod, only:  mesh_score, nmesh
   use event_log_mod, only : eventp, EVENTP_SURFACE, BANK_ANNIHILATION
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -82,6 +83,13 @@ subroutine electron_history_4c3
         if( lca(icl)<0 ) then
           call chkcel(icl,3,j)
         endif
+        
+        ! DAGMC: In DAGMC mode, use the known physics distance to limit geometry search
+        if ( isdgmc == 1 ) then
+           d = min(dtc,pmf)
+           call dagmc_setdis(d)
+        endif
+        
 
         call track(icl)
         if( kdb/=0 )  go to 999 ! Return
diff -rupN Source-orig/src/fmesh_mod.F90 Source/src/fmesh_mod.F90
--- Source-orig/src/fmesh_mod.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/fmesh_mod.F90	2016-03-18 16:28:36.514327791 -0500
@@ -10,6 +10,8 @@ module fmesh_mod
   use mcnp_iofiles
   use mcnp_params, only: dknd
   use erprnt_mod
+  use dagmc_mod
+
   implicit none
   public
   save
@@ -17,6 +19,8 @@ module fmesh_mod
   logical :: lmtout = .false.  != Flag indicating the status of the mesh 
                                !=  tally output file.
 
+  logical :: enable_dag_collision_tallies = .false. != DAGMC: Flag indiciating presence of KDE tally
+
   integer, parameter :: nfmsh = 15      != Number of keywords on the  FMESH card
 
   integer :: &
@@ -123,10 +127,83 @@ module fmesh_mod
 
   private ::  dosef_fmesh, wtmult_fmesh
 
+
+  ! DAGMC: These helper functions must be called with non-dereferenced Fortran pointers.
+  ! This interface specification ensures that the calls to these functions
+  ! (which are implemented in C) are made with the correct types
+  interface
+     subroutine dagmc_fmesh_get_tally_data( idx, fref )
+       implicit none
+       integer :: idx
+       ! The dknd parameter is unavailable in this scope for some reason,
+       ! so I have copied the definition of dknd from mcnp_params
+       real(selected_real_kind(15,307)) , dimension(:), pointer :: fref 
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_tally_data
+
+     subroutine dagmc_fmesh_get_error_data( idx, fref )
+       implicit none
+       integer :: idx
+       real(selected_real_kind(15,307)) , dimension(:), pointer :: fref
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_error_data
+
+     subroutine dagmc_fmesh_get_scratch_data( idx, fref )
+       implicit none
+       integer :: idx
+       real(selected_real_kind(15,307)), dimension(:), pointer:: fref 
+       !real(dknd), dimension(:), pointer :: fref
+     end subroutine dagmc_fmesh_get_scratch_data
+
+  end interface
+
+
 CONTAINS
 
   !-----------------------------------------------------------------------------------------
 
+  ! DAGMC: Helper function - create a valid Fortran pointer from a C array and a length 
+  subroutine dagmc_make_fortran_pointer( fref, carray, size )
+    implicit none
+
+    integer :: size ! The size (in doubles) of the array in C
+    real(dknd), dimension(size), target :: carray ! The C pointer
+    real(dknd), dimension(:), pointer :: fref     ! The returned Fortran pointer
+    
+    fref => carray
+
+  end subroutine dagmc_make_fortran_pointer
+
+  subroutine dagmc_setup_mesh_tally( idx )
+    implicit none
+    integer :: idx
+    integer :: dagmc_iscol
+
+    print *, shape(fm(idx)%fmarry)
+
+    ! Setup dagmc mesh; paramaters will be read in from FC card
+    if( fm(idx)%n_comment_lines > 0 ) then 
+       call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, idx, &
+                                    fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                    fm(idx)%comment, fm(idx)%n_comment_lines, dagmc_iscol )
+    else
+       ! No FC card; avoid passing uninitialized pointer to C
+       ! The following call will halt mcnp with an error because of the missing card.
+       ! We could also signal an error and halt here instead.
+       call dagmc_fmesh_setup_mesh( fm(idx)%ipt, fm(idx)%id, idx, &
+                                    fm(idx)%enbin, fm(idx)%nenb, fm(idx)%tot_energy_bin, &
+                                    0, 0, dagmc_iscol )
+    endif
+    
+    if( dagmc_iscol == 1 ) then 
+       enable_dag_collision_tallies = .true. 
+    endif
+    
+  end subroutine dagmc_setup_mesh_tally
+    
+    
+  !-----------------------------------------------------------------------------------------
+
   subroutine fmesh_runtpw(iu)
     !  subroutine to write mesh tallies to the RUNTPE
 
@@ -134,7 +211,11 @@ CONTAINS
 
     integer, intent(in) :: iu          !Unit number
     integer            :: i,ix,iy,iz,ie
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
  
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_runtpw'
+
     !  first write the number of meshes
     write(iu) nmesh
     if( nmesh==0 ) return
@@ -178,6 +259,15 @@ CONTAINS
     do i = 1,nmesh
          write(iu) fm(i)%fmarry(:,:,:,:,1), & 
       &          fm(i)%fmerr( :,:,:,:,1)
+
+       ! DAGMC: 
+       if ( fm(i)%icrd==3 ) then          
+          ! Get pointer to mesh's working data and fill runtpe with those contents
+          call dagmc_fmesh_get_tally_data( i, dagmc_runtpe_data )
+          write(iu) dagmc_runtpe_data
+          call dagmc_fmesh_get_error_data( i, dagmc_runtpe_data )
+          write(iu) dagmc_runtpe_data
+       endif
     enddo
 
     return
@@ -188,7 +278,7 @@ CONTAINS
   subroutine fmesh_runtpr(iu)
     !  subroutine to read mesh tallies from the RUNTPE
 
-    use mcnp_global, only:ntasks,iovr
+    use mcnp_global, only:ntasks,iovr,icl
     use mcnp_data, only: thrd_runtpe
 
     integer, intent(in) :: iu          !Unit number
@@ -199,6 +289,11 @@ CONTAINS
     logical    :: is_assoc            ! flag to test pointer association 
 #endif
 
+    real(dknd), dimension(:), pointer :: dagmc_runtpe_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_runtpr'
+
     ! If called from mcplot, deallocate the arrays if allocated
 
     if ( nmesh > 0 .and. iovr == 5 ) then
@@ -250,6 +345,8 @@ CONTAINS
     ! Next read in the scalar and non-allocatable arrays  of derived type fm
     do i = 1,nmesh
        if ( thrd_runtpe == 'unknown' ) then
+          ! From reading tpefil.F90, I think this branch only executes if runtpe file 
+          ! has suffered a read failure-- which should be uncommon. --sjackson
          read(iu)  fm(i)%id,fm(i)%ipt,fm(i)%icrd,fm(i)%itr,fm(i)%icx,fm(i)%intrpol, &
             &  fm(i)%nxrb,fm(i)%nyzb,fm(i)%nztb,fm(i)%nenb,fm(i)%ndfb,fm(i)%ifm_card,   &
             &  fm(i)%nreact,fm(i)%nireact,fm(i)%mat,fm(i)%outf,fm(i)%fact,fm(i)%fmult,&
@@ -345,6 +442,20 @@ CONTAINS
           fm(i)%fmerr(:,:,:,:,j) = 0
        enddo
        fmtal(i)%tally = 0
+
+
+       if ( fm(i)%icrd==3 ) then 
+          ! DAGMC:
+          if( .not. is_assoc ) call dagmc_setup_mesh_tally( i )
+
+          ! Get pointer to mesh's working memory and fill it with runtpe data
+          call dagmc_fmesh_get_tally_data( i, dagmc_runtpe_data )
+          read(iu) dagmc_runtpe_data
+          call dagmc_fmesh_get_error_data( i, dagmc_runtpe_data )
+          read(iu) dagmc_runtpe_data
+ 
+       endif
+
      enddo
 
     ! Allocate scratch arrays
@@ -382,6 +493,9 @@ CONTAINS
     character(6)  :: intpol_mode  ! Dose response function interpolation mod
     character(13) :: ht(18)       ! FM card reaction list/attenuation set
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: ifmesh_print'
+
     do i = 1,nmesh
 
        ! print tally id, and type
@@ -508,6 +622,9 @@ CONTAINS
 
     integer :: i, is
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_allocate'
+
     if( .not. allocated(fm) ) then
 
       allocate( fm(nmesh),  fmtal(nmesh), meshid(nmesh+10), intrpol(nmesh+10),  &
@@ -581,6 +698,9 @@ CONTAINS
     real(dknd), intent(inout) :: t    ! particle weight
     integer   , intent(in)    :: kk   ! Mesh tally number
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: wtmult_fmesh'
+
     jf = 0
     id = 0
     if( fm(kk)%ifm_card<0  )  go to 280
@@ -758,7 +878,11 @@ CONTAINS
 
     use messages
 
-    integer :: i
+    integer :: i,j
+    
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgput'
+
 
     call msg_put(nmesh)
 
@@ -805,6 +929,15 @@ CONTAINS
           call msg_put (fm(i)%df, 1, fm(i)%ndfb)
        endif
 
+       ! DAGMC: send comment contents if this is a dagmc mesh
+       if( fm(i)%icrd == 3 ) then
+          call msg_put( fm(i)%n_comment_lines )
+
+          do j=1,fm(i)%n_comment_lines
+             call msg_put( fm(i)%comment(j) )
+          enddo
+       endif
+
     enddo Loop1
 
     return
@@ -818,9 +951,13 @@ CONTAINS
     ! called from msgtsk
 
     use messages
-    use mcnp_global, only: ntasks
+    use mcnp_global, only: ntasks, icl
 
     integer :: i,ix,iy,iz,ie,is
+    integer :: j
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgget'
 
     call msg_get(nmesh)
 
@@ -898,6 +1035,19 @@ CONTAINS
           call msg_get (fm(i)%df, 1, fm(i)%ndfb)
        endif
 
+       ! DAGMC: receive comment contents if this is a dagmc mesh
+       if( fm(i)%icrd == 3 ) then
+          call msg_get( fm(i)%n_comment_lines )
+
+          allocate( fm(i)%comment( fm(i)%n_comment_lines ), stat=is )
+          if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
+
+          do j=1,fm(i)%n_comment_lines 
+             call msg_get( fm(i)%comment(j) )
+          enddo
+
+       endif
+
        ! allocate mesh tally arrays
 
        ix = fm(i)%nxrb-1
@@ -938,6 +1088,13 @@ CONTAINS
     if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
     num_bins=0
 
+   ! DAGMC: 
+    do i = 1,nmesh
+       if( fm(i)%icrd == 3 ) then
+          call dagmc_setup_mesh_tally( i )
+       endif
+    enddo
+
     return
   end subroutine fmesh_msgget
 
@@ -950,6 +1107,10 @@ CONTAINS
     use messages
 
     integer :: i,ix,iy,iz,ie,isize
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgcon'
 
     do i = 1,nmesh
        ix = fm(i)%nxrb-1
@@ -961,6 +1122,7 @@ CONTAINS
          ie = fm(i)%nenb-1
        endif
 
+       if( fm(i)%icrd /= 3 ) then 
        isize = ix*iy*iz*ie
 
        call msg_get(fmtal(i)%tally, 1, isize)
@@ -970,6 +1132,17 @@ CONTAINS
        call msg_get(fmtal(i)%tally, 1, isize)
        fm(i)%fmerr(:,:,:,:,1) = fm(i)%fmerr(:,:,:,:,1)+  &
             &   fmtal(i)%tally(:,:,:,:,1)
+       
+       else
+          ! DAGMC
+          call dagmc_fmesh_get_scratch_data( i, dagmc_mpi_data )
+          call msg_get( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_add_scratch_to_tally( i )
+          call msg_get( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_add_scratch_to_error( i )
+
+       endif
+
     enddo
 
     return
@@ -985,6 +1158,10 @@ CONTAINS
 
     integer :: i
     integer :: ix,iy,iz,ie,isize
+    real(dknd), dimension(:), pointer :: dagmc_mpi_data
+
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_msgtsk'
 
     do i = 1,nmesh
        ix = fm(i)%nxrb-1
@@ -996,6 +1173,8 @@ CONTAINS
          ie = fm(i)%nenb-1
        endif
 
+       if( fm(i)%icrd /= 3 ) then
+
        isize = ix*iy*iz*ie
        call msg_put(fm(i)%fmarry, 1, isize)
        call msg_put(fm(i)%fmerr, 1, isize)
@@ -1003,6 +1182,17 @@ CONTAINS
        ! zero arrays
        fm(i)%fmarry(:,:,:,:,1) = 0
        fm(i)%fmerr(:,:,:,:,1) = 0
+       
+       else
+          ! DAGMC
+          call dagmc_fmesh_get_tally_data( i, dagmc_mpi_data )
+          call msg_put( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_get_error_data( i, dagmc_mpi_data )
+          call msg_put( dagmc_mpi_data, 1, size(dagmc_mpi_data) )
+          call dagmc_fmesh_clear_data( i )
+
+       endif
+
     enddo
 
     return
@@ -1019,6 +1209,9 @@ CONTAINS
 
     integer :: i,kt,kt1
 
+    ! DAGMC: 
+    call dagmc_fmesh_end_history()
+
     kt = ktask+2
     kt1= ktask+1
     if(num_bins(kt1) < i_size_bins) then
@@ -1067,6 +1260,55 @@ CONTAINS
   end subroutine mesh_end_history
 
   !-----------------------------------------------------------------------------------------
+  
+  subroutine dagmc_mesh_choose_ebin( i, erg, ien )
+    integer :: i, ien
+    real(dknd) :: erg
+    
+    ! See if energy is within the desired bins
+    if( fm(i)%nenb>1 ) then
+       if( erg<fm(i)%enbin(1) .or. erg>fm(i)%enbin(fm(i)%nenb)) then
+          ien = -1
+       else
+          ien = ibin_search(erg,fm(i)%enbin,fm(i)%nenb)
+       endif
+    else
+       ien = 1
+    endif
+
+  end subroutine dagmc_mesh_choose_ebin
+
+  !-----------------------------------------------------------------------------------------
+
+  subroutine dagmc_mesh_score( i, erg, wgt, d, score )
+
+    use mcnp_params, only:dknd
+    use mcnp_global, only:rho,icl
+
+    integer   , intent(in) :: i
+    real(dknd), intent(in) :: erg,wgt,d 
+    real(dknd), intent(out) :: score
+    real(dknd) :: t
+
+    t = 1._dknd
+    if( fm(i)%ifm_card/=0 ) then
+       call wtmult_fmesh(t,i)
+    endif
+    t = t*fm(i)%fmult
+    if( fm(i)%fmult < 0 ) t = -t*rho(icl)
+    
+    if ( fm(i)%ifm_card == -1 ) then ! Special tally multiplier -- # of tracks
+       score = t
+    else
+       score = d*wgt*t
+       if ( fm(i)%icx == 1 ) score = score*erg
+       if ( fm(i)%intrpol /= 0 ) score = score*dosef_fmesh(erg,i)
+    endif
+
+    return
+  end subroutine dagmc_mesh_score
+          
+  !-----------------------------------------------------------------------------------------
 
   subroutine mesh_score(ipt,x,y,z,u,v,w,erg,wgt,d)
 
@@ -1094,6 +1336,7 @@ CONTAINS
     ! return if kcode problem is not settled
     if ( kc8>0 ) return
 
+  
     kt = ktask+2
     kt1= ktask+1
 
@@ -1103,6 +1346,22 @@ CONTAINS
 
        if( ipt/=fm(i)%ipt) cycle Loop1
 
+       ! DAGMC: 
+       if ( fm(i)%icrd==3 ) then
+
+          ! See if energy is within the desired bins
+          if( fm(i)%nenb>1 ) then
+             if( erg<fm(i)%enbin(1) .or. erg>fm(i)%enbin(fm(i)%nenb)) cycle Loop1
+             
+             ien = ibin_search(erg,fm(i)%enbin,fm(i)%nenb)
+          else
+             ien = 1
+          endif
+
+          call dagmc_fmesh_score(i,x,y,z,u,v,w,erg,wgt,d,ien)
+          cycle
+       endif
+
        ! select coordinate system
 
        if( fm(i)%icrd==2 ) then
@@ -1294,6 +1553,7 @@ CONTAINS
              endif
 
             ! Score the track length
+            ! DAGMC: begin borrowed source for subroutine dagmc_mesh_score
 
             t = 1._dknd
             if( fm(i)%ifm_card/=0 ) then
@@ -1309,6 +1569,7 @@ CONTAINS
               if ( fm(i)%icx == 1 ) score = score*erg
               if ( fm(i)%intrpol /= 0 ) score = score*dosef_fmesh(erg,i)
             endif
+            ! DAGMC: end borrowed source 
 
             fmtal(i)%tally(ixr,iyz,izt,ien,kt)=  fmtal(i)%tally(ixr,iyz,izt,ien,kt)+score
             fm(i)%fmarry(ixr,iyz,izt,ien,kt)  =    fm(i)%fmarry(ixr,iyz,izt,ien,kt)+score
@@ -1377,6 +1638,9 @@ CONTAINS
     integer    :: nextbin(3)        ! Next bin indicator
     integer    :: j,k,il,iu,im,ien,ixr,iyz,izt,kt,kt1
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: mesh_score_cyl'
+
     kt = ktask+2
     kt1= ktask+1
 
@@ -1685,26 +1949,43 @@ CONTAINS
     implicit real(dknd) (a-h,o-z)
     integer i,j,iibin,ix,iy,iz,ie,is
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmsh_setup'
+    ! For a dagmc mesh (icrd==3), origin and bins information will be missing
+    ! In these cases, allocate a single bin in all directions to keep this code happy
+
     !  get total number of bins for each coordinate and allocate memory
 
-    fm(nmesh)%nxrb = 1
-    do i = 1,ifmsh(6)
-       fm(nmesh)%nxrb = fm(nmesh)%nxrb+ixrtmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nxrb = 1
+       do i = 1,ifmsh(6)
+          fm(nmesh)%nxrb = fm(nmesh)%nxrb+ixrtmp(i)
+       enddo
+    else
+       fm(nmesh)%nxrb = 2
+    endif
     allocate (fm(nmesh)%xrbin(fm(nmesh)%nxrb),stat = is)
     if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
 
-    fm(nmesh)%nyzb = 1
-    do i = 1,ifmsh(8)
-       fm(nmesh)%nyzb = fm(nmesh)%nyzb+iyztmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nyzb = 1
+       do i = 1,ifmsh(8)
+          fm(nmesh)%nyzb = fm(nmesh)%nyzb+iyztmp(i)
+       enddo
+    else
+       fm(nmesh)%nyzb = 2 
+    endif
     allocate (fm(nmesh)%yzbin(fm(nmesh)%nyzb),stat = is)
     if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
 
-    fm(nmesh)%nztb = 1
-    do i = 1,ifmsh(10)
-       fm(nmesh)%nztb = fm(nmesh)%nztb+izttmp(i)
-    enddo
+    if( fm(nmesh)%icrd /= 3 ) then
+       fm(nmesh)%nztb = 1
+       do i = 1,ifmsh(10)
+          fm(nmesh)%nztb = fm(nmesh)%nztb+izttmp(i)
+       enddo
+    else
+       fm(nmesh)%nztb = 2
+    endif
     allocate (fm(nmesh)%ztbin(fm(nmesh)%nztb),stat = is)
     if(is/=0) call erprnt(1,1,0,0,0,0,0,1,' "mesh tally memory allocation failure"')
 
@@ -1829,6 +2110,9 @@ CONTAINS
     real(dknd), intent(in) :: erg
     real(dknd)             :: dosef_fmesh
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: dosef_fmesh'
+
     ! use extreme value if energy is off either end of the table.
     if( erg>=fm(im)%de(fm(im)%ndfb) ) then
        dosef_fmesh = fm(im)%df(fm(im)%ndfb)
@@ -1889,6 +2173,9 @@ CONTAINS
     real(dknd) sp_norm
     character(len=1024) :: bigstring
 
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_print'
+
     ! Get  the source particle normalization.
     sp_norm = 1./fpi
 
@@ -1928,6 +2215,12 @@ CONTAINS
 
     do j = 1,nmesh
 
+       ! DAGMC
+       if( fm(j)%icrd == 3 ) then
+          call dagmc_fmesh_print( j, sp_norm, fm(j)%fact ) 
+          cycle
+       endif
+
        !  convert theta bins from radians to revolutions
 
        if( fm(j)%icrd==2) fm(j)%ztbin = fm(j)%ztbin/(2_dknd*pie)
@@ -2394,6 +2687,9 @@ CONTAINS
    
     logical ::  found_tally
 
+    ! DAGMC DEBUGGING
+    !print '(a80)', 'DAGMC MESTHAL: fmesh_initialize'
+
     !  cycle through the id numbers
     Loop1: do i = 1,ndf
 
@@ -2700,6 +2996,13 @@ CONTAINS
        call ifmesh_print
     endif
 
+   ! DAGMC: 
+    do i = 1,nmesh
+       if( fm(i)%icrd == 3 ) then
+          call dagmc_setup_mesh_tally( i )
+       endif
+    enddo
+    
     return
 
   end subroutine fmesh_initialize
@@ -2715,6 +3018,9 @@ CONTAINS
     integer, intent(in) :: ktask
     integer  :: i,kt
  
+    ! DAGMC DEBUGGING
+    ! print '(a80)', 'DAGMC MESTHAL: fmesh_vtask'
+   
     kt = ktask+2
     do i=1,nmesh
       fm(i)%fmarry(:,:,:,:,1) = fm(i)%fmarry(:,:,:,:,1)+fm(i)%fmarry(:,:,:,:,kt) 
@@ -2735,6 +3041,9 @@ CONTAINS
   integer   ,intent(in)  ::  num_bins
   integer                ::  il,iu,im,ibin_search
 
+  ! DAGMC DEBUGGING
+  !  print '(a80)', 'DAGMC MESTHAL: ibin_search'
+
     il = 0
     iu = num_bins+1
     do while (iu-il > 1)
diff -rupN Source-orig/src/getpar.F90 Source/src/getpar.F90
--- Source-orig/src/getpar.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/getpar.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,12 +9,19 @@ subroutine getpar(k1,k2)
   !       = 0 to not save repeated structures data.
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
   n = k1
   if( k1==0 )  n = npb
   if( k1==0 )  npb = npb-1
+
+  ! DAGMC: Restore the ray history associated with this particle
+  if (isdgmc == 1) then 
+     call dagmc_getpar(n)
+  endif
+
   !
   ! retrieve the integer particle attributes.
   do i = 1,lpblcm
diff -rupN Source-orig/src/hstory.F90 Source/src/hstory.F90
--- Source-orig/src/hstory.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/hstory.F90	2016-03-18 16:28:36.514327791 -0500
@@ -16,9 +16,10 @@ subroutine hstory
    &                   pair_production, incoher_dxtran_node, &
    &                   increase_phtvr_memory, master_thread_locked, threads_running, &
    &                   threads_stopped, increase_phtvr_arrays, PHTVR_LOCK, max_n_nodes
-  use fmesh_mod, only: mesh_end_history, mesh_score, nmesh
+  use fmesh_mod, only: mesh_end_history, mesh_score, nmesh, enable_dag_collision_tallies
   use event_log_mod, only : eventp, EVENTP_FROM_BANK, EVENTP_SURFACE, &
     &         EVENTP_COLLISION, EVENTP_TERMINATED
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   real(dknd)       :: sr(3), sd(3)
@@ -108,7 +109,8 @@ subroutine hstory
   endif
 
   ! Calculate the distance to the cell boundary, dls.
-  if( lca(icl)<0 ) then
+  ! DAGMC: only do this when running in non-CAD mode
+  if( lca(icl)<0 .and. (isdgmc == 0) ) then
     call chkcel(icl,3,j)
   endif
 50 continue
@@ -119,7 +121,8 @@ subroutine hstory
     endif
     call expirx(1,'hstory','the weight of the current particle is zero or less.')
   endif
-  call track(icl)
+  ! DAGMC: only call track here if in normal mode (NOT in CAD mode)
+  if (isdgmc == 0) call track(icl)
   if( kdb/=0 )  go to 390
 
   ! Calculate the distance to the nearest dxtran sphere, dxl.
@@ -176,7 +179,15 @@ subroutine hstory
         ! Sample the distance to collision, pmf, normally.
         pmf = -log(rang())*gs
       else
-        ! Force a collision.
+        ! DAGMC: In CAD mode, call DAGMC before forcing collision
+        if ( isdgmc == 1 ) then
+           if ( lca(icl) < 0 ) call chkcel(icl,3,j)
+           call dagmc_setdis(huge_float)
+           call track(icl)
+           if ( kdb /= 0 ) goto 390
+        endif
+         
+        !  Force a collision.
         call forcol
         if( kdb/=0  )  go to 390
         if( nter/=0 )  go to 260
@@ -189,6 +200,16 @@ subroutine hstory
   ! Banked uncollided forced collision part comes back here.
   ! 1 mfp mesh-based weight window check survivors come back here.
 90 continue
+
+  ! DAGMC: In CAD mode, get particle information
+  if ( isdgmc == 1 ) then
+     if (lca(icl) < 0) call chkcel(icl,3,j)
+     d = min( pmf, dxl, dtc, deb, dw )
+     call dagmc_setdis(d)
+     call track(icl)
+     if ( kdb /= 0 ) goto 390
+  endif
+
   d = min( pmf, dls, dxl, dtc, deb, dw )
 
   ! Adjust the weight for exponential transformation.
@@ -447,6 +468,12 @@ subroutine hstory
       go to 260
     endif
   endif
+
+  ! DAGMC: Collision Tally  
+  if ( enable_dag_collision_tallies ) then
+    call dagmc_collision_score( ipt, xxx, yyy, zzz, erg, wgt, ple, icl )
+  endif
+
   if(     ipt==1 ) then
     call colidn
   elseif( ipt==2 ) then
@@ -492,6 +519,8 @@ subroutine hstory
 
   ! Increment particle statistics for termination type nter.
 260 continue
+
+  if (isdgmc == 1) call dagmc_particle_terminate()
   if ( phtvr_flag == 1 ) then
     !  termination node for track
     !  no termination node for pair production if positrons
diff -rupN Source-orig/src/igeom.F90 Source/src/igeom.F90
--- Source-orig/src/igeom.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/igeom.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,6 +8,7 @@ subroutine igeom
   use mcnp_input
   use dynamic_arrays
   use erprnt_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -100,7 +101,8 @@ subroutine igeom
 
   ! expand # operators and check the cells and surfaces.
 80 continue
-  call chekcs
+  ! DAGMC: only call this when running in normal (non-CAD) mode
+  if (isdgmc == 0) call chekcs
 
   ! calculate the constants of any lattices in the geometry.
   if( nlat/=0 ) then
diff -rupN Source-orig/src/imcn.F90 Source/src/imcn.F90
--- Source-orig/src/imcn.F90	2016-03-18 16:10:51.731486817 -0500
+++ Source/src/imcn.F90	2016-03-18 16:28:36.514327791 -0500
@@ -13,7 +13,7 @@ subroutine imcn
   use crit1_mod
   use fmesh_mod, only: nmesh, fmesh_initialize
   use phtvr_mod, only: forced_collision_flag, phtvr_flag
-
+  use dagmc_mod
 
 
 
@@ -435,6 +435,12 @@ contains
       &                   new_stride       = RN_stride_input,  &
       &                   new_part1        = RN_hist_input     )
 
+    ! Initialize DAGMC
+    if (isdgmc == 1) then   ! set DAGMC parameters from idum & rdum
+       call dagmc_set_settings(dagmc_distlimit, dagmc_usecad, dagmc_overlap_thickness, dagmc_srcmode)
+    endif
+       
+
     if( uran_n>0 ) then
       write(jtty,17) (uran_univ(j),(uran_xyz(i,j),i=1,3),j=1,uran_n)
 17    format(1x,/, &
diff -rupN Source-orig/src/itally.F90 Source/src/itally.F90
--- Source-orig/src/itally.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/itally.F90	2016-03-18 16:28:36.514327791 -0500
@@ -18,6 +18,7 @@ subroutine itally
   use fmesh_mod,  only:  nmesh
   use phtvr_mod, only: initialize_phtvr
   use erprnt_mod
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=1) :: h
@@ -90,6 +91,13 @@ subroutine itally
         j = rtp(ipnt(1,7+m,ital)-1+i)
         k = namchg(2*m-1,j)
         if( k==0 ) go to 40
+
+        ! DAGMC: If in CAD mode, skip up until line prior to marker 40
+        if ( isdgmc == 1 ) then
+          itds(li+i) = k
+          goto 40
+        endif
+
         ! if macrobody identical surface, use master surface number.
         if( m==2 ) then
           ! check if a bounding surface, include facet if macrobody.
diff -rupN Source-orig/src/main.F90 Source/src/main.F90
--- Source-orig/src/main.F90	2016-03-18 16:10:51.731486817 -0500
+++ Source/src/main.F90	2016-03-18 16:28:36.514327791 -0500
@@ -53,21 +53,14 @@ program main
   use crit2_mod
   use ra1_mod
   use ra2_mod
-
-
-
-
-
-
-
-
-
-
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
   character(len=18) :: hn = '                  '
   character(len=80) :: hp
+  
+
   ! --------------------------------------------------------------
 
   ! Nullify pointer in mcnp_global
@@ -153,6 +146,32 @@ program main
   endif
 
   call exemes
+
+  ! DAGMC: initialize a DAGMC run if specified
+  if (gcad /= ' ') then
+     isdgmc = 1
+
+     if (mcnp_opt_multp) dagmc_geom_file_mode = DGFM_READ;
+
+  else
+     
+     ! Error checking for user specifying worthless files
+     if(lcad /= ' ') then
+        call expire(0,'main','CAD list file specified &
+             &   without a geometry file.')
+     endif
+     if(fcad /= ' ') then
+        call expire(0,'main','CAD facet file specified &
+             &   without a geometry file.')
+     endif
+     if(ftol /= ' ') then
+        call expire(0,'main','Facet tolerance specified &
+             &   without a geometry file.')
+     endif
+     
+  endif
+  
+
   if( konrun==0 )  probid = idtm
 
   ! Alternate method for setting ltasks for MPI-based versions.
@@ -187,10 +206,15 @@ program main
       if( file_exists )  call expire(0,'main',&
         & 'name='//iname//' fails. '//isub(i)//' already exists.')
     endif
-    if( isub(i)==' ' .and. msub(i)/='com' )  isub(i)=msub(i)
+    if( isub(i)==' ' .and. msub(i)/='com' .and. msub(i)/='fcad')  isub(i)=msub(i)
+     
   enddo
   call set_filenames
 
+  if (isdgmc == 1) then
+     call init_dagmc
+  endif 
+
   ! Create the output print file and write heading on it.
   call unique(outp,jtty)
   open(iuo,file=outp,status='new')
@@ -202,6 +226,7 @@ program main
 170 format( "1",a8, " version ",a5, " ld=",a8,8x,a10,2x,a19/&
     & ,1x,73( "*"),:17x, "probid = ",a19)
   write(iuo,'(1x,a80/)') exms
+  if (isdgmc == 1) call dagmc_version_heading(iuo)
 
   call ttyint
 
diff -rupN Source-orig/src/mcnp_input.F90 Source/src/mcnp_input.F90
--- Source-orig/src/mcnp_input.F90	2016-03-18 16:10:51.731486817 -0500
+++ Source/src/mcnp_input.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,7 +8,7 @@ module mcnp_input
   integer,private :: i                  ! Local loop variable.
 
   ! Module Parameters:
-integer,parameter :: nkcd   = 105     != Number of different types of input cards.
+  integer,parameter :: nkcd   = 107     != Number of different types of input cards.
   integer,parameter :: ntalmx = 1000    != Maximum number of tallies.
   integer,parameter :: mopts  = 7       != Number of M card options (gas, estep, etc.).
 
@@ -123,6 +123,12 @@ integer,parameter :: nkcd   = 105     !=
   ! rand card keywords, input values
   character(len=6), parameter ::  hrand(4) = (/'gen   ','seed  ','stride','hist  '/)
 
+  ! dagmc card keywords, input values
+  character(len=18), parameter :: hdagmc(4) = (/'check_src_cell    ', &
+    &                                           'usecad            ', &
+    &                                           'distlimit         ', &
+    &                                           'overlap_thickness ' /)
+
   !  ----------------------------------------------------------------------
   ! initialize data for imcn.
   integer,parameter,private :: nx=5*mxdx+3
@@ -245,4 +251,6 @@ integer,parameter :: nkcd   = 105     !=
   data cnm(103),(krq(i,103),i=1,7)/ 'uran ',0,0, 0,0, 0,   0,0 / 
   data cnm(104),(krq(i,104),i=1,7)/ 'hsrc ',0,0, 0,0, 0,   0,0 / 
   data cnm(105),(krq(i,105),i=1,7)/ 'var  ',0,0, 0,0, 0,   0,0 / 
+  data cnm(107),(krq(i,107),i=1,7)/ 'dagmc',0,0, 0,0, 0,  12,0 / 
 end module mcnp_input
+  
diff -rupN Source-orig/src/mcnp_iofiles.F90 Source/src/mcnp_iofiles.F90
--- Source-orig/src/mcnp_iofiles.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/mcnp_iofiles.F90	2016-03-18 16:28:36.514327791 -0500
@@ -34,7 +34,11 @@ module mcnp_iofiles
     &  wwinp   , &  != weight windows input name.
     &  meshtal , &  != meshtally output file
     &  dumn1   , &
-    &  dumn2   
+    &  dumn2   , &
+    &  gcad    , &  != DAGMC geometry input file (CAD or facets)
+    &  lcad    , &  != DAGMC input log file
+    &  fcad    , &  != DAGMC facets output file
+    &  ftol         != DAGMC faceting tolerance
 
   ! isub:  names of files.
   character(len=256) ::  isub(ndef)  != Runtime file names.
@@ -75,6 +79,10 @@ contains
     meshtal = isub(16)
     dumn1   = isub(17)
     dumn2   = isub(18)
+    gcad    = isub(19)
+    lcad    = isub(20)
+    fcad    = isub(21)
+    ftol    = isub(22)
     return
   end subroutine set_filenames
 
@@ -103,6 +111,10 @@ contains
       meshtal(i:i) = ' '
       dumn1(i:i)  = ' '
       dumn2(i:i)  = ' '
+      gcad(i:i)   = ' '
+      lcad(i:i)   = ' '
+      fcad(i:i)   = ' '
+      ftol(i:i)   = ' '
       do j=1,ndef
         isub(j)(i:i) = ' '
         msub(j)(i:i) = ' '
@@ -127,6 +139,10 @@ contains
     msub(16)(1:8) = 'meshtal '
     msub(17)(1:8) = 'dumn1   '
     msub(18)(1:8) = 'dumn2   '
+    msub(19)(1:8) = 'gcad    '
+    msub(20)(1:8) = 'lcad    '
+    msub(21)(1:8) = 'fcad    '
+    msub(22)(1:8) = 'ftol    '
 
   end subroutine init_filenames
 
diff -rupN Source-orig/src/mcnp_params.F90 Source/src/mcnp_params.F90
--- Source-orig/src/mcnp_params.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/mcnp_params.F90	2016-03-18 16:28:36.514327791 -0500
@@ -130,6 +130,7 @@ module mcnp_params
   integer,parameter :: iumt = 54        != I/O unit for the mesh tally output file
   integer,parameter :: iuwe = 55        != I/O unit for output WWOUT file.
   integer,parameter :: iuw1 = 56        != I/O unit for output WWONE file.
+  integer,parameter :: iulc = 57        != I/O unit for DAGMC log file
   integer,parameter :: iub  = 60        != I/O unit for bank backup file.
 
   integer,parameter :: uran_mx = 2      != max number of random universe translations
diff -rupN Source-orig/src/msgcon.F90 Source/src/msgcon.F90
--- Source-orig/src/msgcon.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/msgcon.F90	2016-03-18 16:28:36.514327791 -0500
@@ -17,7 +17,7 @@ subroutine msgcon( msgcon_action )
   use phtvr_mod, only:  phtvr_msgput
   use qttyin_mod, only: qttyin
   use erprnt_mod, only: erprnt, erprnt_i8_k1
-
+  use dagmc_mod 
 
 
 
@@ -169,6 +169,11 @@ subroutine msgcon( msgcon_action )
   call phtvr_msgput
   call dm_send(-1,14,i)
 
+  write(jtty,*) "master sending DAGMC information...."
+  call dm_sndi
+  call dagmc_msgput
+  call dm_send(-1,20,i)
+
   ! Send cross section data.
   if( lxs>0 ) then
     write(jtty,*) "master sending cross section data..."
diff -rupN Source-orig/src/msgtsk.F90 Source/src/msgtsk.F90
--- Source-orig/src/msgtsk.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/msgtsk.F90	2016-03-18 16:28:36.514327791 -0500
@@ -17,7 +17,7 @@ subroutine msgtsk
   use messages
   use fmesh_mod, only:  fmesh_msgget, fmesh_msgtsk
   use phtvr_mod, only:  phtvr_msgget
-
+  use dagmc_mod
 
 
 
@@ -94,6 +94,9 @@ subroutine msgtsk
   call fmesh_msgget
   call phtvr_msgget
 
+  call dm_recv(-1,20,i)
+  call dagmc_msgget  
+
   ! Receive cross section data.
   if( lxs>0 ) then
     is_assoc = associated(xss)
diff -rupN Source-orig/src/namchg.F90 Source/src/namchg.F90
--- Source-orig/src/namchg.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/namchg.F90	2016-03-18 16:28:36.514327791 -0500
@@ -6,15 +6,19 @@ function namchg(mm,ji)
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
-  if( mm==2 ) then
+  ! DAGMC: Need to change some of these conditionals, no bounding
+  !        surfaces exist in CAD mode, handle as regular surface
+
+  if( ( mm==2 ) .or. ( ( mm == 3) .and. ( isdgmc == 1 ) ) ) then
     !  >>>>>  mm=2 -- surface
     do namchg=1,mxj
       if( nsf(namchg)==abs(ji) )  return
     end do
-  elseif( mm==3 ) then
+  elseif( ( mm==3 ) .and. ( isdgmc == 0 ) ) then
     !  >>>>>  mm=3 -- bounding surface
     do kk=1,nlja
       namchg = abs(lja(kk))
diff -rupN Source-orig/src/newcel.F90 Source/src/newcel.F90
--- Source-orig/src/newcel.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/newcel.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,8 +8,17 @@ subroutine newcel(cs)
   use mcnp_global
   use mcnp_debug
   use uran_mod
+  use dagmc_mod
+
   implicit real(dknd) (a-h,o-z)
    
+  ! DAGMC: In CAD mode, call MOAB version of this
+  if ( isdgmc == 1 ) then
+    if ( cs /= 0 ) cs = angl()
+    call dagmcnewcel(jsu,icl,iap)
+    if ( mxa == -1 ) kdb = 1
+  endif
+
   ! shift to the higher level if one was found in track.
   if( levp/=lev ) then
     lev = levp
@@ -33,7 +42,10 @@ subroutine newcel(cs)
   if( iovr==2 ) then
     kdb = 1
   else
-    call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    ! DAGMC: Only check this if running normally, (NOT in CAD mode)
+    if (isdgmc == 0) then
+      call expirx(1,'newcel','the surface crossed is not a surface of this cell.')
+    endif
   endif
   return
 
diff -rupN Source-orig/src/nextit.F90 Source/src/nextit.F90
--- Source-orig/src/nextit.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/nextit.F90	2016-03-18 16:28:36.514327791 -0500
@@ -11,7 +11,7 @@ subroutine nextit
   use erprnt_mod
   use entropy_mod
   use phtvr_mod, only: phtvr_flag, Russian_Roulette
-
+  use dagmc_mod
 
 
 
@@ -1467,6 +1467,7 @@ subroutine nextit
         ifmsh(m1c) = ifmsh(m1c)+1
         if( hitm(1:3)=='xyz' .or. hitm(1:3)=='rec' )  fm(nmesh)%icrd=1
         if( hitm(1:3)=='rzt' .or. hitm(1:3)=='cyl' )  fm(nmesh)%icrd=2
+        if( hitm(1:3)=='dag' )                        fm(nmesh)%icrd=3 ! DAGMC option
         return
       endif
       if( hfmsh(m1c)=='out    ' .and. ifmsh(m1c)==0 ) then
@@ -1636,6 +1637,29 @@ subroutine nextit
         Russian_Roulette = 0
       endif
     endif 
+
+  case( 107 )
+    !  >>>>>  DAGMC parameters                                          dagmc
+    !  Modeled after RAND (99)
+    ! m1c=index of current dagmc keyword.
+    if( m1c == 0 ) then
+      if( index(',=',hitm(1:1))==0 ) then
+        do m1c = 1,4
+          if( hitm(1:18)==hdagmc(m1c) )  return
+        enddo
+        m1c = 0
+      endif
+    else
+      if( index(',=',hitm(1:1))==0 ) then
+        if( m1c==1 .and. ( hitm(1:2) == 'of' .or. hitm(1:2) == 'no') )  dagmc_srcmode = 1 
+        if( m1c==2 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_usecad = 1
+        if( m1c==3 .and. ( hitm(1:2) == 'on' .or. hitm(1:2) == 'ye') )  dagmc_distlimit = 1
+        if( m1c==4 )  dagmc_overlap_thickness = ritm
+        m1c = 0
+      endif
+    endif
+
+
   end select
   return
 end subroutine nextit
diff -rupN Source-orig/src/oldcrd.F90 Source/src/oldcrd.F90
--- Source-orig/src/oldcrd.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/oldcrd.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,7 +9,7 @@ subroutine oldcrd
   use mcnp_input
   use fmesh_mod
   use erprnt_mod
-
+  use dagmc_mod
 
 
 
@@ -33,7 +33,8 @@ subroutine oldcrd
     if( likef==0 ) then
       if(m1c /= 0)  call erprnt(2,1,0,0,0,0,0,0,'  "parentheses used incorrectly."')
       lca(mxa+1) = nlja+1
-      if( lca(mxa)==nlja+1 ) &
+      ! DAGMC: In CAD mode, cells should have no surfaces
+      if( ( lca(mxa)==nlja+1 ) .and. ( isdgmc == 0 ) ) &
         & call erprnt(2,1,0,0,0,0,0,0,'  "this cell has no surfaces."')
     else
       call likebt(2)
@@ -45,6 +46,10 @@ subroutine oldcrd
     !  >>>>>  surface descriptions
     ! m1c=surface type index.
     ! m2c=1 if surface type symbol is the second item.
+
+    ! DAGMC: Break out of subroutine here in CAD mode
+     if ( isdgmc == 1 ) return
+
     ix = lsc(mxj)
     if( (m1c==1 .and. nwc>5+m2c) .or. &
       & (m1c>=27 .and. m1c<=29)   .or. m1c>39 ) then
@@ -748,10 +753,13 @@ subroutine oldcrd
 
   case( 98 )
     !  >>>>>  track-length mesh tallies                                 fmesh
+     ! DAGMC: skip handling imesh/jmesh/kmesh/orig when geom=DAG; check emesh before jump
+    if( ifmsh(13)==0 ) ientmp(1:ifmsh(12)) = 1
+     if( fm(nmesh)%icrd==3 ) goto 4900
     if( ifmsh(7)==0 )  ixrtmp(1:ifmsh(6)) = 1
     if( ifmsh(9)==0 )  iyztmp(1:ifmsh(8)) = 1
     if( ifmsh(11)==0 ) izttmp(1:ifmsh(10)) = 1
-    if( ifmsh(13)==0 ) ientmp(1:ifmsh(12)) = 1
+
     if( ifmsh(6)==0 )  call erprnt(1,1,0,0,0,0,0,1,&
       & '  "imesh keyword missing from fmesh card."')
     if( ifmsh(8)==0 )  call erprnt(1,1,0,0,0,0,0,1,&
@@ -858,6 +866,7 @@ subroutine oldcrd
         endif
      endif
 
+4900 continue ! DAGMC jump target
      if( ifmsh(14)==0) fm(nmesh)%fact = 1.0
 
      call fmsh_setup
diff -rupN Source-orig/src/pass1.F90 Source/src/pass1.F90
--- Source-orig/src/pass1.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/pass1.F90	2016-03-18 16:28:36.514327791 -0500
@@ -11,9 +11,13 @@ subroutine pass1
   use mcnp_debug
   use mcnp_input
   use dynamic_arrays
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
+  ! DAGMC: For CAD mode, read cell/surface cards from log file
+  if ( isdgmc == 1) call lcadrd
+
   ! Process 3 data blocks, which are separated by blank lines.
   rewind iu1
   DO_50: do ib=1,3
diff -rupN Source-orig/src/read_line.F90 Source/src/read_line.F90
--- Source-orig/src/read_line.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/read_line.F90	2016-03-18 16:28:36.514327791 -0500
@@ -23,7 +23,7 @@ subroutine read_line( iunit, line, ierr
 
   nch  = len(line)
   ierr = 0
-  line = ' '
+  line = " "
  
   ! read an input line
   read(iunit,'(a)', iostat=istat) line
diff -rupN Source-orig/src/reflec.F90 Source/src/reflec.F90
--- Source-orig/src/reflec.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/reflec.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,6 +8,7 @@ subroutine reflec
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -71,5 +72,6 @@ subroutine reflec
     zzz = udt(3,l)
   endif
   if( lca(icl)<0 )  call chkcel(icl,3,j)
+  if( isdgmc == 1 ) call dagmc_surf_reflection( uuu, vvv, www, 0 )
   return
 end subroutine reflec
diff -rupN Source-orig/src/savpar.F90 Source/src/savpar.F90
--- Source-orig/src/savpar.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/savpar.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,6 +9,7 @@ subroutine savpar(k1,k2)
   !       = 0 to not save repeated structures data.
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
 
@@ -16,6 +17,12 @@ subroutine savpar(k1,k2)
   if( k1==0 )  n = npb+1
   if( n>mpb )  go to 40
   if( k1==0 )  npb = n
+
+  ! DAGMC: save this particle's ray history
+  if (isdgmc == 1) then 
+     call dagmc_savpar(n)
+  endif
+
   !
   ! save the real particle attributes.
   do i = 1,npblcm
diff -rupN Source-orig/src/sourcb.F90 Source/src/sourcb.F90
--- Source-orig/src/sourcb.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/sourcb.F90	2016-03-18 16:28:36.514327791 -0500
@@ -6,7 +6,8 @@ subroutine sourcb
  
   use mcnp_global
   use mcnp_debug
- 
+  use dagmc_mod
+
   implicit real(dknd) (a-h,o-z)
   character(len=5) ::  hc
   real(dknd) :: fb(maxv), sf(3)
@@ -514,7 +515,12 @@ subroutine sourcb
 400 continue
     if( icl>0  ) then
       ji = icl
-      call chkcel(ji,0,j)
+      ! DAGMC: if dagmc_srcmode is on, skip chkcel and assume particle is in user-specified cell
+      if( isdgmc==1 .and. dagmc_srcmode==1 ) then 
+         j = 0
+      else
+         call chkcel(ji,0,j)
+      endif
       isef(kise+1,ji) = isef(kise+1,ji)+1_i8knd
       if( j/=0 )  go to 425
     elseif( icl<0 ) then
@@ -563,7 +569,8 @@ subroutine sourcb
  
   ! default for cel:  find the cell that contains xyz.
 470 continue
-  if( icl==0 ) then
+
+   if( icl==0 ) then
     if( junf==0 ) then
       do m=1,nlse
         icl = lse(klse+m)
diff -rupN Source-orig/src/startp.F90 Source/src/startp.F90
--- Source-orig/src/startp.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/startp.F90	2016-03-18 16:28:36.514327791 -0500
@@ -13,6 +13,7 @@ subroutine startp
   use rmc_mod
   use event_log_mod, only : eventp, EVENTP_SOURCE
   use phtvr_mod, only: phtvr_flag, n_branches, n_nodes, branch_wgt, n_choices
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=130) :: ha
@@ -56,6 +57,10 @@ subroutine startp
   kdb  = 0
   nbnk = 0
   jbnk = 0
+ ! DAGMC: nbnk = 0
+  if ( isdgmc == 1 ) then
+     call dagmc_bank_clear
+  endif
   kqss = 0
   mbb  = 0
   lev  = 0
diff -rupN Source-orig/src/tally.F90 Source/src/tally.F90
--- Source-orig/src/tally.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/tally.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,6 +8,7 @@ subroutine tally( lo, dr )
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   integer :: ik(8), ii(3)
@@ -290,6 +291,10 @@ subroutine tally( lo, dr )
     if( iptal(4,1,ital)==0 )  go to 470
     ig = iptal(4,1,ital)
     call chkcel(ig,3,j)
+
+    ! DAGMC: If in CAD mode, make sure distance to physics collision is initialized
+    if ( isdgmc == 1 ) call dagmc_setdis(huge_float)
+
     call track(ig)
     if( kdb/=0 )  go to 999 ! Return
     n = iptal(4,4,ital)-2
diff -rupN Source-orig/src/track.F90 Source/src/track.F90
--- Source-orig/src/track.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/track.F90	2016-03-18 16:28:36.514327791 -0500
@@ -12,6 +12,7 @@ subroutine track(ih)
   use mcnp_global
   use mcnp_debug
   use qttyin_mod, only: qttyin
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   real(dknd) :: dl(0:mxlv)
@@ -23,6 +24,15 @@ subroutine track(ih)
       call qttyin(-1,' "nps =",i12,5x,  "collisions =",i6')
     endif
   endif
+
+  ! DAGMC: If in CAD mode, call DAGMC version of track instead
+  if ( isdgmc == 1 ) then    
+    call dagmctrack(ih,uuu,vvv,www,xxx,yyy,zzz,huge_float,dls, &
+     &               jap,jsu,nps)
+    if ( dls == huge_float ) kdb = 2
+    return
+  endif
+
   ll = lev
   ic = ih
 
diff -rupN Source-orig/src/transm.F90 Source/src/transm.F90
--- Source-orig/src/transm.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/transm.F90	2016-03-18 16:28:36.514327791 -0500
@@ -8,6 +8,8 @@ subroutine transm(dd,st,iz)
 
   use mcnp_global
   use mcnp_debug
+  use dagmc_mod
+
   implicit real(dknd) (a-h,o-z)
 
   iz = 0
@@ -30,6 +32,8 @@ subroutine transm(dd,st,iz)
     endif
 
     ! calculate the attenuation for this section of the track.
+    ! DAGMC: If in CAD mode, call dagmc_setdis first
+    if ( isdgmc == 1 ) call dagmc_setdis( dd - sd )
     call track(icl)
     if( kdb/=0 ) go to 90
     totm = 0.
diff -rupN Source-orig/src/volume.F90 Source/src/volume.F90
--- Source-orig/src/volume.F90	2016-03-18 16:10:51.735486786 -0500
+++ Source/src/volume.F90	2016-03-18 16:28:36.514327791 -0500
@@ -9,10 +9,17 @@ subroutine volume
   use mcnp_input
   use qttyin_mod, only: qttyin
   use erprnt_mod, only: erprnt
+  use dagmc_mod
 
   implicit real(dknd) (a-h,o-z)
   character(len=23) :: hh
   
+  ! DAGMC: In CAD mode, circumvent most of this function and call DAGMC version
+  if (isdgmc == 1) then
+    call dagmcvolume(mxa,vols,mxj,aras)
+    goto 260
+  endif
+
   ! assume y-axis symmetry to start with.
   bbb(1:4,1:4) = 0.
   bbb(1,1) = 1.
